<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>blog</title><link rel="manifest" href="../../manifest.json"><meta name="application-name" content="blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="blog"><meta property="og:url" content="https://0914ds.github.io/"><meta property="og:site_name" content="blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://0914ds.github.io/img/og_image.png"><meta property="article:author" content="albert dong"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://0914ds.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://0914ds.github.io"},"headline":"blog","image":["https://0914ds.github.io/img/og_image.png"],"author":{"@type":"Person","name":"albert dong"},"publisher":{"@type":"Organization","name":"blog","logo":{"@type":"ImageObject","url":"https://0914ds.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="../../img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="../../css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="atom.xml" title="blog" type="application/atom+xml">
</head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="../../index.html"><img src="../../img/logo.svg" alt="blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="../../index.html">Home</a><a class="navbar-item" href="../../archives">Archives</a><a class="navbar-item" href="../../categories">Categories</a><a class="navbar-item" href="../../tags">Tags</a><a class="navbar-item" href="../../about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-09T18:45:12.000Z" title="2023/5/10 02:45:12">2023-05-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-06-22T07:27:52.708Z" title="2023/6/22 15:27:52">2023-06-22</time></span><span class="level-item"><a class="link-muted" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span><span class="level-item">13 minutes read (About 1995 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2023/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/graphdatabase/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93nebulaGraph%E9%80%89%E5%9E%8B/">图数据库nebulaGraph选型</a></p><div class="content"><h1 id="nebulagraph-选型">nebulaGraph 选型</h1>
<h2 id="一.why-nebulagraph">一.why nebulaGraph ？</h2>
<p>在图数据库的选型上我们主要考虑了以下 5 点：(A)
项目开源，暂不考虑需付费的图数据库；(B)
分布式架构设计，具备良好的可扩展性；© 毫秒级的多跳查询延迟；(D)
支持千亿量级点边存储；(E) 具备批量从数仓导入数据的能力。</p>
<p>分析 DB-Engines[2] 上排名前 30
的图数据库，剔除不开源的项目，我们将剩余的图数据库分为三类：</p>
<ul>
<li><strong>第一类：Neo4j[3]、ArangoDB[4]、Virtuoso[5]、TigerGraph[6]、RedisGraph[7]。</strong>
此类图数据库只有单机版本开源可用，性能优秀，但不能应对分布式场景中数据的规模增长，即不满足选型要求（B）、（D）。</li>
<li><strong>第二类：JanusGraph[8]、HugeGraph[9]。</strong>
此类图数据库在现有存储系统之上新增了通用的图语义解释层，图语义层提供了图遍历的能力，但是受到存储层或者架构限制，不支持完整的计算下推，多跳遍历的性能较差，很难满足
OLTP 场景下对低延时的要求，即不满足选型要求（C）。</li>
<li><strong>第三类：DGraph[10]、NebulaGraph[11]。</strong>
此类图数据库根据图数据的特点对数据存储模型、点边分布、执行引擎进行了全新设计，对图的多跳遍历进行了深度优化，基本满足我们的选型要求。</li>
</ul>
<p>DGraph 是由前 Google 员工 Manish Rai Jain 离职创业后，在 2016
年推出的图数据库产品，底层数据模型是 RDF[12]，基于 Go
语言编写，存储引擎基于 BadgerDB[13] 改造，使用 RAFT
保证数据读写的强一致性。</p>
<p>NebulaGraph 是由前 Facebook 员工叶小萌离职创业后，在 2019年
推出的图数据库产品，底层数据模型是属性图，基于 C++
语言编写，存储引擎基于 RocksDB[14] 改造，使用 RAFT
保证数据读写的强一致性。</p>
<p>这两个项目的创始人都在互联网公司图数据库领域深耕多年，对图数据库的落地痛点有深刻认识，整体的架构设计也有较多相似之处。在图数据库最终的选型上，我们基于
LDBC-SNB 数据集[15]对 NebulaGraph、DGraph、HugeGraph
进行了深度性能测评，测试详情见文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg4OTg0MzY0Mw==&amp;mid=2247492115&amp;idx=1&amp;sn=1fd71049c940f9ee0013782cf6733a14&amp;source=41#wechat_redirect">主流开源分布式图数据库
Benchmark</a>，从测试结果看 NebulaGraph
在数据导入、实时写入及多跳查询方面性能均优于竞品。此外，NebulaGraph
社区活跃，问题响应速度快，所以团队最终选择基于 NebulaGraph
来搭建图数据库平台</p>
<h2 id="二.nebulagraph架构">二.nebulagraph架构</h2>
<figure>
<img src="/2023/05/10/%E6%95%B0%E6%8D%AE%E5%BA%93/graphdatabase/%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%BA%93nebulaGraph%E9%80%89%E5%9E%8B//nebulaGraph架构.png" alt="nebulaGraph架构">
<figcaption aria-hidden="true">nebulaGraph架构</figcaption>
</figure>
<p>一个完整的 NebulaGraph 集群包含三类服务，即 Query Service、Storage
Service 和 Meta
Service。每类服务都有其各自的可执行二进制文件，既可以部署在同一节点上，也可以部署在不同的节点上。下面是NebulaGraph
架构设计（见图 3）的几个核心点[16][17]。</p>
<ul>
<li><strong>Meta Service：</strong> 架构图中右侧为 Meta Service
集群，它采用 Leader/Follower 架构。Leader 由集群中所有的 Meta Service
节点选出，然后对外提供服务；Followers 处于待命状态，并从 Leader
复制更新的数据。一旦 Leader 节点 Down 掉，会再选举其中一个 Follower
成为新的 Leader。Meta Service 不仅负责存储和提供图数据的 Meta 信息，如
Schema、数据分片信息等；同时还提供 Job Manager
机制管理长耗时任务，负责指挥数据迁移、Leader 变更、数据
compaction、索引重建等运维操作。</li>
<li><strong>存储计算分离：</strong> 在架构图中 Meta Service 的左侧，为
NebulaGraph 的主要服务，NebulaGraph
采用存储与计算分离的架构，虚线以上为计算，以下为存储。存储计算分离有诸多优势，最直接的优势就是，计算层和存储层可以根据各自的情况弹性扩容、缩容。存储计算分离还带来了另一个优势：使水平扩展成为可能。此外，存储计算分离使得
Storage Service 可以为多种类型的计算层或者计算引擎提供服务。当前 Query
Service 是一个高优先级的 OLTP 计算层，而各种 OLAP
迭代计算框架会是另外一个计算层。</li>
<li><strong>无状态计算层：</strong>
每个计算节点都运行着一个无状态的查询计算引擎，而节点彼此间无任何通信关系。计算节点仅从
Meta Service 读取 Meta 信息以及和 Storage Service
进行交互。这样设计使得计算层集群更容易使用 K8s
管理或部署在云上。每个查询计算引擎都能接收客户端的请求，解析查询语句，生成抽象语法树（AST）并将
AST 传递给执行计划器和优化器，最后再交由执行器执行。</li>
<li><strong>Shared-nothing 分布式存储层：</strong> Storage Service 采用
Shared-nothing 的分布式架构设计，共有三层，最底层是 Store
Engine，它是一个单机版 Local Store
Engine，提供了对本地数据的get/put/scan/delete
操作，该层定义了数据操作接口，用户可以根据自己的需求定制开发相关 Local
Store Plugin。目前，NebulaGraph 提供了基于 RocksDB 实现的 Store
Engine。在 Local Store Engine 之上是 Consensus 层，实现了 Multi Group
Raft，每一个 Partition 都对应了一组 Raft Group。在 Consensus 层上面是
Storage interfaces，这一层定义了一系列和图相关的 API。 这些 API
请求会在这一层被翻译成一组针对相应 Partition 的 KV
操作。正是这一层的存在，使得存储服务变成了真正的图存储。否则，Storage
Service 只是一个 KV 存储罢了。而 NebulaGraph 没把 KV
作为一个服务单独提出，最主要的原因便是图查询过程中会涉及到大量计算，这些计算往往需要使用图的
Schema，而 KV 层没有数据 Schema 概念，这样设计比较容易实现计算下推，是
NebulaGraph 查询性能优越的主要原因。</li>
</ul>
<p>NebulaGraph 基于 C++
实现，架构设计支持存储千亿顶点、万亿边，并提供毫秒级别的查询延时。我们在
3 台 48U192G 物理机搭建的集群上灌入 10 亿美食图谱数据对 NebulaGraph
的功能进行了验证。</p>
<ul>
<li>一跳查询 TP99 延时在 5ms 内，两跳查询 TP99 延时在 20ms
内，一般的多跳查询 TP99 延时在百毫秒内。</li>
<li>集群在线写入速率约为20万 Records/s。</li>
<li>支持通过 Spark 任务离线生成 RocksDB 底层 SST
File，直接将数据文件载入到集群中，即类似 HBase BulkLoad 能力。</li>
<li>提供了类 SQL 查询语言，对于新增的业务需求，只需构造 NebulaGraph SQL
语句，易于理解且能满足各类复杂查询要求。</li>
<li>提供联合索引、GEO
索引，可通过实体属性或者关系属性查询实体、关系，或者查询在某个经纬度附近
N 米内的实体。</li>
<li>一个 NebulaGraph 集群中可以创建多个 Space （概念类似 MySQL
的DataBase），并且不同 Space 中的数据在物理上是隔离的。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T18:45:12.000Z" title="2022/3/11 02:45:12">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-02T05:38:22.717Z" title="2023/7/2 13:38:22">2023-07-02</time></span><span class="level-item"><a class="link-muted" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/">JVM调优合集</a></span><span class="level-item">24 minutes read (About 3629 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/">jvm系列(三):GC算法 垃圾收集器</a></p><div class="content"><h1 id="jvm系列三gc算法-垃圾收集器">jvm系列(三):GC算法 垃圾收集器</h1>
<h2 id="概述">概述</h2>
<p>垃圾收集 Garbage Collection 通常被称为“GC”，它诞生于1960年 MIT 的
Lisp 语言，经过半个多世纪，目前已经十分成熟了。 jvm
中，程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理，因此，我们的内存垃圾回收主要集中于
java 堆和方法区中，在程序运行期间，这部分内存的分配和使用都是动态的.</p>
<h2 id="对象存活判断">对象存活判断</h2>
<p>判断对象是否存活一般有两种方式：</p>
<p><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
<strong>可达性分析</strong>（Reachability Analysis）：从GC
Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC
Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
<p>在Java语言中，GC Roots包括：</p>
<ul>
<li>虚拟机栈中引用的对象。</li>
<li>方法区中类静态属性实体引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI引用的对象。</li>
</ul>
<h2 id="垃圾收集算法">垃圾收集算法</h2>
<h3 id="标记--清除算法">标记 -清除算法</h3>
<p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p>
<p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702123629.png" alt="微信截图_20230702123629">
<figcaption aria-hidden="true">微信截图_20230702123629</figcaption>
</figure>
<h3 id="复制算法">复制算法</h3>
<p>“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702123740.png" alt="微信截图_20230702123740">
<figcaption aria-hidden="true">微信截图_20230702123740</figcaption>
</figure>
<h3 id="标记-压缩算法">标记-压缩算法</h3>
<p>复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702123823.png" alt="微信截图_20230702123823">
<figcaption aria-hidden="true">微信截图_20230702123823</figcaption>
</figure>
<h3 id="分代收集算法">分代收集算法</h3>
<p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p>
<p>“分代收集”（Generational
Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p>
<h2 id="垃圾收集器">垃圾收集器</h2>
<blockquote>
<p>如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现</p>
</blockquote>
<h3 id="serial收集器">Serial收集器</h3>
<p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop
The World（服务暂停）</p>
<p>参数控制： <code>-XX:+UseSerialGC</code> 串行收集器</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702123859.png" alt="微信截图_20230702123859">
<figcaption aria-hidden="true">微信截图_20230702123859</figcaption>
</figure>
<p>ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-压缩</p>
<p>参数控制：</p>
<p><code>-XX:+UseParNewGC</code> ParNew收集器
<code>-XX:ParallelGCThreads</code> 限制线程数量</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702123937.png" alt="微信截图_20230702123937">
<figcaption aria-hidden="true">微信截图_20230702123937</figcaption>
</figure>
<h3 id="parallel收集器">Parallel收集器</h3>
<p>Parallel
Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-压缩</p>
<p>参数控制： <code>-XX:+UseParallelGC</code> 使用Parallel收集器+
老年代串行</p>
<h3 id="parallel-old-收集器">Parallel Old 收集器</h3>
<p>Parallel Old是Parallel
Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK
1.6中才开始提供</p>
<p>参数控制： <code>-XX:+UseParallelOldGC</code> 使用Parallel收集器+
老年代并行</p>
<h3 id="cms收集器">CMS收集器</h3>
<p>CMS（Concurrent Mark
Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p>
<p>从名字（包含“Mark
Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>其中初始标记、重新标记这两个步骤仍然需要“Stop The
World”。初始标记仅仅只是标记一下GC
Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots
Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。老年代收集器（新生代使用ParNew）</p>
<p><strong>优点</strong>: 并发收集、低停顿 <strong>缺点</strong>:
产生大量空间碎片、并发阶段会降低吞吐量</p>
<p>参数控制：</p>
<p><code>-XX:+UseConcMarkSweepGC</code> 使用CMS收集器
<code>-XX:+ UseCMSCompactAtFullCollection</code> Full
GC后，进行一次碎片整理；整理过程是独占的，会引起停顿时间变长
<code>-XX:+CMSFullGCsBeforeCompaction</code> 设置进行几次Full
GC后，进行一次碎片整理 <code>-XX:ParallelCMSThreads</code>
设定CMS的线程数量（一般情况约等于可用CPU数量）</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702124017.png" alt="微信截图_20230702124017">
<figcaption aria-hidden="true">微信截图_20230702124017</figcaption>
</figure>
<h3 id="g1收集器">G1收集器</h3>
<p>G1是目前技术发展的最前沿成果之一，HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与CMS收集器相比G1收集器有以下特点：</p>
<ol type="1">
<li><strong>空间整合</strong>，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC。</li>
<li><strong>可预测停顿</strong>，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li>
</ol>
<p>上面提到的垃圾收集器，收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔阂了，它们都是一部分（可以不连续）Region的集合。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702124101.png" alt="微信截图_20230702124101">
<figcaption aria-hidden="true">微信截图_20230702124101</figcaption>
</figure>
<p>G1的新生代收集跟ParNew类似，当新生代占用达到一定比例的时候，开始出发收集。和CMS类似，G1收集器收集老年代对象会有短暂停顿。</p>
<p>收集步骤：</p>
<p>1、标记阶段，首先初始标记(Initial-Mark),这个阶段是停顿的(Stop the
World Event)，并且会触发一次普通Mintor GC。对应GC log:GC pause (young)
(inital-mark)</p>
<p>2、Root Region
Scanning，程序运行过程中会回收survivor区(存活到老年代)，这一过程必须在young
GC之前完成。</p>
<p>3、Concurrent
Marking，在整个堆中进行并发标记(和应用程序并发执行)，此过程可能被young
GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，会计算每个区域的对象活性(区域中存活对象的比例)。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702124135.png" alt="微信截图_20230702124135">
<figcaption aria-hidden="true">微信截图_20230702124135</figcaption>
</figure>
<p>4、Remark, 再标记，会有短暂停顿(STW)。再标记阶段是用来收集
并发标记阶段
产生新的垃圾(并发阶段和应用程序一同运行)；G1中采用了比CMS更快的初始快照算法:snapshot-at-the-beginning
(SATB)。</p>
<p>5、Copy/Clean
up，多线程清除失活对象，会有STW。G1将回收区域的存活对象拷贝到新区域，清除Remember
Sets，并发清空回收区域并把它返回到空闲区域链表中。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702124210.png" alt="微信截图_20230702124210">
<figcaption aria-hidden="true">微信截图_20230702124210</figcaption>
</figure>
<p>6、复制/清除过程后。回收区域的活性对象已经被集中回收到深蓝色和深绿色区域。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%89)GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8//微信截图_20230702124248.png" alt="微信截图_20230702124248">
<figcaption aria-hidden="true">微信截图_20230702124248</figcaption>
</figure>
<h2 id="常用的收集器组合">常用的收集器组合</h2>
<table>
<colgroup>
<col style="width: 5%">
<col style="width: 17%">
<col style="width: 14%">
<col style="width: 62%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"></th>
<th style="text-align: left;">新生代GC策略</th>
<th style="text-align: left;">老年老代GC策略</th>
<th style="text-align: left;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">组合1</td>
<td style="text-align: left;">Serial</td>
<td style="text-align: left;">Serial Old</td>
<td style="text-align: left;">Serial和Serial
Old都是单线程进行GC，特点就是GC时暂停所有应用线程。</td>
</tr>
<tr class="even">
<td style="text-align: left;">组合2</td>
<td style="text-align: left;">Serial</td>
<td style="text-align: left;">CMS+Serial Old</td>
<td style="text-align: left;">CMS（Concurrent Mark
Sweep）是并发GC，实现GC线程和应用线程并发工作，不需要暂停所有应用线程。另外，当CMS进行GC失败时，会自动使用Serial
Old策略进行GC。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">组合3</td>
<td style="text-align: left;">ParNew</td>
<td style="text-align: left;">CMS</td>
<td style="text-align: left;">使用
<code>-XX:+UseParNewGC</code>选项来开启。ParNew是Serial的并行版本，可以指定GC线程数，默认GC线程数为CPU的数量。可以使用-XX:ParallelGCThreads选项指定GC的线程数。如果指定了选项
<code>-XX:+UseConcMarkSweepGC</code>选项，则新生代默认使用ParNew
GC策略。</td>
</tr>
<tr class="even">
<td style="text-align: left;">组合4</td>
<td style="text-align: left;">ParNew</td>
<td style="text-align: left;">Serial Old</td>
<td style="text-align: left;">使用
<code>-XX:+UseParNewGC</code>选项来开启。新生代使用ParNew
GC策略，年老代默认使用Serial Old GC策略。</td>
</tr>
<tr class="odd">
<td style="text-align: left;">组合5</td>
<td style="text-align: left;">Parallel Scavenge</td>
<td style="text-align: left;">Serial Old</td>
<td style="text-align: left;">Parallel
Scavenge策略主要是关注一个可控的吞吐量：应用程序运行时间 /
(应用程序运行时间 +
GC时间)，可见这会使得CPU的利用率尽可能的高，适用于后台持久运行的应用程序，而不适用于交互较多的应用程序。</td>
</tr>
<tr class="even">
<td style="text-align: left;">组合6</td>
<td style="text-align: left;">Parallel Scavenge</td>
<td style="text-align: left;">Parallel Old</td>
<td style="text-align: left;">Parallel Old是Serial Old的并行版本</td>
</tr>
<tr class="odd">
<td style="text-align: left;">组合7</td>
<td style="text-align: left;">G1GC</td>
<td style="text-align: left;">G1GC</td>
<td style="text-align: left;"><code>-XX:+UnlockExperimentalVMOptions</code>
<code>-XX:+UseG1GC</code> #开启； <code>-XX:MaxGCPauseMillis=50</code>
#暂停时间目标； <code>-XX:GCPauseIntervalMillis=200</code>
#暂停间隔目标； <code>-XX:+G1YoungGenSize=512m</code> #年轻代大小；
<code>-XX:SurvivorRatio=6</code> #幸存区比例</td>
</tr>
</tbody>
</table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T18:45:12.000Z" title="2022/3/11 02:45:12">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-02T05:39:09.152Z" title="2023/7/2 13:39:09">2023-07-02</time></span><span class="level-item"><a class="link-muted" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/">JVM调优合集</a></span><span class="level-item">23 minutes read (About 3410 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/">jvm系列(二):JVM内存结构</a></p><div class="content"><h1 id="jvm系列二jvm内存结构">jvm系列(二):JVM内存结构</h1>
<p>所有的Java开发人员可能会遇到这样的困惑？我该为堆内存设置多大空间呢？OutOfMemoryError的异常到底涉及到运行时数据的哪块区域？该怎么解决呢？其实如果你经常解决服务器性能问题，那么这些问题就会变的非常常见，了解JVM内存也是为了服务器出现性能问题的时候可以快速的了解那块的内存区域出现问题，以便于快速的解决生产故障。</p>
<p>先看一张图，这张图能很清晰的说明JVM内存结构布局。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84//微信截图_20230702122127.png" alt="微信截图_20230702122127">
<figcaption aria-hidden="true">微信截图_20230702122127</figcaption>
</figure>
<p>JVM内存结构主要有三大块：<strong>堆内存</strong>、<strong>方法区</strong>和<strong>栈</strong>。堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，<strong>Eden空间</strong>、<strong>From
Survivor空间</strong>、<strong>To
Survivor空间</strong>,默认情况下年轻代按照<strong>8:1:1</strong>的比例来分配；</p>
<p>方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；栈又分为java虚拟机栈和本地方法栈主要用于方法的执行。</p>
<p>在通过一张图来了解如何通过参数来控制各区域的内存大小</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84//微信截图_20230702122241.png" alt="微信截图_20230702122241">
<figcaption aria-hidden="true">微信截图_20230702122241</figcaption>
</figure>
<p>控制参数</p>
<ul>
<li>-Xms设置堆的最小空间大小。</li>
<li>-Xmx设置堆的最大空间大小。</li>
<li>-XX:NewSize设置新生代最小空间大小。</li>
<li>-XX:MaxNewSize设置新生代最大空间大小。</li>
<li>-XX:PermSize设置永久代最小空间大小。</li>
<li>-XX:MaxPermSize设置永久代最大空间大小。</li>
<li>-Xss设置每个线程的堆栈大小。</li>
</ul>
<p>没有直接设置老年代的参数，但是可以设置堆空间大小和新生代空间大小两个参数来间接控制。</p>
<blockquote>
<p>老年代空间大小=堆空间大小-年轻代大空间大小</p>
</blockquote>
<p>从更高的一个维度再次来看JVM和系统调用之间的关系</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84//微信截图_20230702122343.png" alt="微信截图_20230702122343">
<figcaption aria-hidden="true">微信截图_20230702122343</figcaption>
</figure>
<p>方法区和对是所有线程共享的内存区域；而java栈、本地方法栈和程序员计数器是运行是线程私有的内存区域。</p>
<p>下面我们详细介绍每个区域的作用</p>
<h2 id="java堆heap">Java堆（Heap）</h2>
<p>对于大多数应用来说，Java堆（Java
Heap）是Java虚拟机所管理的内存中<strong>最大</strong>的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代；再细致一点的有Eden空间、From
Survivor空间、To Survivor空间等。</strong></p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h2 id="方法区method-area">方法区（Method Area）</h2>
<p>方法区（Method
Area）与Java堆一样，是各个线程共享的内存区域，<strong>它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p>对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent
Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。</p>
<p>Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。</p>
<p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<p>方法区有时被称为持久代（PermGen）。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84//微信截图_20230702122437.png" alt="微信截图_20230702122437">
<figcaption aria-hidden="true">微信截图_20230702122437</figcaption>
</figure>
<p>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor
Sapce)，老年代（Old Generation Space）。</p>
<p>方法的执行都是伴随着线程的。原始类型的本地变量以及引用都存放在线程栈中。而引用关联的对象比如String，都存在在堆中。为了更好的理解上面这段话，我们可以看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.text.SimpleDateFormat;import java.util.Date;import org.apache.log4j.Logger;public class HelloWorld &#123;    private static Logger LOGGER = Logger.getLogger(HelloWorld.class.getName());    public void sayHello(String message) &#123;        SimpleDateFormat formatter = new SimpleDateFormat(&quot;dd.MM.YYYY&quot;);        String today = formatter.format(new Date());        LOGGER.info(today + &quot;: &quot; + message);    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这段程序的数据在内存中的存放如下：</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84//微信截图_20230702122529.png" alt="微信截图_20230702122529">
<figcaption aria-hidden="true">微信截图_20230702122529</figcaption>
</figure>
<p>通过JConsole工具可以查看运行中的Java程序（比如Eclipse）的一些信息：堆内存的分配，线程的数量以及加载的类的个数</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%8C)JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84//微信截图_20230702122635.png" alt="微信截图_20230702122635">
<figcaption aria-hidden="true">微信截图_20230702122635</figcaption>
</figure>
<h2 id="程序计数器program-counter-register">程序计数器（Program Counter
Register）</h2>
<p>程序计数器（Program Counter
Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined）。</p>
<p><strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</strong></p>
<h2 id="jvm栈jvm-stacks">JVM栈（JVM Stacks）</h2>
<p>与程序计数器一样，Java虚拟机栈（Java Virtual Machine
Stacks）也是线程私有的，<strong>它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：</strong>每个方法被执行的时候都会同时创建一个栈帧（Stack
Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</strong></p>
<p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。</p>
<h2 id="本地方法栈native-method-stacks">本地方法栈（Native Method
Stacks）</h2>
<p>本地方法栈（Native Method
Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务。</strong>虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun
HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h2 id="哪儿的outofmemoryerror">哪儿的OutOfMemoryError</h2>
<p>对内存结构清晰的认识同样可以帮助理解不同OutOfMemoryErrors：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<p>原因：对象不能被分配到堆内存中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
<p>原因：类或者方法不能被加载到老年代。它可能出现在一个程序加载很多类的时候，比如引用了很多第三方的库；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: Requested array size exceeds VM limit</span><br></pre></td></tr></table></figure>
<p>原因：创建的数组大于堆内存的空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: request &lt;size&gt; bytes for &lt;reason&gt;. Out of swap space?</span><br></pre></td></tr></table></figure>
<p>原因：分配本地分配失败。JNI、本地库或者Java虚拟机都会从本地堆中分配内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread “main”: java.lang.OutOfMemoryError: &lt;reason&gt; &lt;stack trace&gt;（Native method）</span><br></pre></td></tr></table></figure>
<p>原因：同样是本地方法内存分配失败，只不过是JNI或者本地方法或者Java虚拟机发现</p>
<h2 id="维基百科对jvm的介绍">维基百科对JVM的介绍</h2>
<p>Overview of a Java virtual machine (JVM) architecture based on The
Java Virtual Machine Specification Java SE 7 Edition</p>
<p>A <strong>Java virtual machine</strong> (<strong>JVM</strong>) is an
abstract computing machine that enables a computer to run a Java
program. There are three notions of the JVM: specification,
implementation, and instance. The specification is a document that
formally describes what is required of a JVM implementation. Having a
single specification ensures all implementations are interoperable. A
JVM implementation is a computer program that meets the requirements of
the JVM specification. An instance of a JVM is an implementation running
in a process that executes a computer program compiled into Java
bytecode.</p>
<p><strong>Java Runtime Environment</strong> (<strong>JRE</strong>) is a
software package that contains what is required to run a Java program.
It includes a Java Virtual Machine implementation together with an
implementation of the Java Class Library. The Oracle Corporation, which
owns the Java trademark, distributes a Java Runtime environment with
their Java Virtual Machine called HotSpot.</p>
<p><strong>Java Development Kit</strong> (<strong>JDK</strong>) is a
superset of a JRE and contains tools for Java programmers, e.g. a
javaccompiler. The Java Development Kit is provided free of charge
either by Oracle Corporation directly, or by the OpenJDK open source
project, which is governed by Oracle.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T18:45:12.000Z" title="2022/3/11 02:45:12">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-02T05:37:26.737Z" title="2023/7/2 13:37:26">2023-07-02</time></span><span class="level-item"><a class="link-muted" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/">JVM调优合集</a></span><span class="level-item">13 minutes read (About 1916 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90/">jvm系列(五):Java GC 分析</a></p><div class="content"><h1 id="jvm系列五java-gc-分析">jvm系列(五):Java GC 分析</h1>
<p>Java GC就是JVM记录仪，书画了JVM各个分区的表演</p>
<h2 id="什么是-java-gc">什么是 Java GC</h2>
<p>Java GC（Garbage
Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java
Virtual
Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver
Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p>
<p>在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java
GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java
GC机制。</p>
<p>简单总结一下，Java
GC就是通过GC收集器回收不在存活的对象，保证JVM更加高效的运转。如果不了解GC算法和垃圾回收器可以参考这篇文章：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483952&amp;idx=1&amp;sn=ea12792a9b7c67baddfaf425d8272d33&amp;chksm=ebf6da4fdc815359869107a4acd15538b3596ba006b4005b216688b69372650dbd18c0184643&amp;scene=21#wechat_redirect">jvm系列(三):GC算法
垃圾收集器。</a></p>
<h2 id="如何获取-java-gc日志">如何获取 Java GC日志</h2>
<p>一般情况可以通过两种方式来获取GC日志，一种是使用命令动态查看，一种是在容器中设置相关参数打印GC日志。</p>
<h3 id="命令动态查看">命令动态查看</h3>
<p>Java
自动的工具行命令，jstat可以用来动态监控JVM内存的使用，统计垃圾回收的各项信息。</p>
<p>比如常用命令， <code>jstat-gc</code> 统计垃圾回收堆的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262 S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT   26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815</span><br></pre></td></tr></table></figure>
<p>也可以设置间隔固定时间来打印：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262 2000 20</span><br></pre></td></tr></table></figure>
<p>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次</p>
<p>更详细的内容参考这篇文章：<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483966&amp;idx=1&amp;sn=dfa3375d36aa2c0c25a775522e381e62&amp;chksm=ebf6da41dc815357e0d53c73865a23f41219e75bac5a4d510bfa31cc51594b59a20e2e4f6cb8&amp;scene=21#wechat_redirect">jvm系列(四):jvm调优-命令篇</a></p>
<h3 id="gc参数">GC参数</h3>
<p>JVM的GC日志的主要参数包括如下几个：</p>
<ul>
<li><code>-XX:+PrintGC</code> 输出GC日志</li>
<li><code>-XX:+PrintGCDetails</code> 输出GC的详细日志</li>
<li><code>-XX:+PrintGCTimeStamps</code>
输出GC的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDateStamps</code> 输出GC的时间戳（以日期的形式，如
2017-09-04T21:53:59.234+0800）</li>
<li><code>-XX:+PrintHeapAtGC</code> 在进行GC的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li>
</ul>
<p>在生产环境中，根据需要配置相应的参数来监控JVM运行情况。</p>
<h3 id="tomcat-设置示例">Tomcat 设置示例</h3>
<p>我们经常在tomcat的启动参数中添加JVM相关参数，这里有一个典型的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-server -Xms2000m -Xmx2000m -Xmn800m -XX:PermSize=64m -XX:MaxPermSize=256m -XX:SurvivorRatio=4-verbose:gc -Xloggc:$CATALINA_HOME/logs/gc.log -Djava.awt.headless=true -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Dsun.rmi.dgc.server.gcInterval=600000 -Dsun.rmi.dgc.client.gcInterval=600000-XX:+UseConcMarkSweepGC -XX:MaxTenuringThreshold=15&quot;</span><br></pre></td></tr></table></figure>
<p>根据上面的参数我们来做一下解析：</p>
<p><code>-Xms2000m-Xmx2000m-Xmn800m-XX:PermSize=64m-XX:MaxPermSize=256m</code>
Xms，即为jvm启动时得JVM初始堆大小,Xmx为jvm的最大堆大小，xmn为新生代的大小，permsize为永久代的初始大小，MaxPermSize为永久代的最大空间。</p>
<p><code>-XX:SurvivorRatio=4</code>
SurvivorRatio为新生代空间中的Eden区和救助空间Survivor区的大小比值，默认是32，也就是说Eden区是
Survivor区的32倍大小，要注意Survivo是有两个区的，因此Surivivor其实占整个young
genertation的1/34。调小这个参数将增大survivor区，让对象尽量在survitor区呆长一点，减少进入年老代的对象。去掉救助空间的想法是让大部分不能马上回收的数据尽快进入年老代，加快年老代的回收频率，减少年老代暴涨的可能性，这个是通过将-XX:SurvivorRatio
设置成比较大的值（比如65536)来做到。</p>
<p><code>-verbose:gc-Xloggc:$CATALINA_HOME/logs/gc.log</code>
将虚拟机每次垃圾回收的信息写到日志文件中，文件名由file指定，文件格式是平文件，内容和-verbose:gc输出内容相同。</p>
<p><code>-Djava.awt.headless=true</code>
Headless模式是系统的一种配置模式。在该模式下，系统缺少了显示设备、键盘或鼠标。</p>
<p><code>-XX:+PrintGCTimeStamps-XX:+PrintGCDetails</code>
设置gc日志的格式</p>
<p><code>-Dsun.rmi.dgc.server.gcInterval=600000-Dsun.rmi.dgc.client.gcInterval=600000</code>
指定rmi调用时gc的时间间隔</p>
<p><code>-XX:+UseConcMarkSweepGC-XX:MaxTenuringThreshold=15</code>
采用并发gc方式，经过15次minor gc 后进入年老代</p>
<h2 id="如何分析gc日志">如何分析GC日志</h2>
<p>摘录GC日志一部分</p>
<p>Young GC回收日志:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-05T10:43:18.093+0800: 25.395: [GC [PSYoungGen: 274931K-&gt;10738K(274944K)] 371093K-&gt;147186K(450048K), 0.0668480 secs] [Times: user=0.17 sys=0.08, real=0.07 secs]</span><br></pre></td></tr></table></figure>
<p>Full GC回收日志:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-07-05T10:43:18.160+0800: 25.462: [Full GC [PSYoungGen: 10738K-&gt;0K(274944K)] [ParOldGen: 136447K-&gt;140379K(302592K)] 147186K-&gt;140379K(577536K) [PSPermGen: 85411K-&gt;85376K(171008K)], 0.6763541 secs] [Times: user=1.75 sys=0.02, real=0.68 secs]</span><br></pre></td></tr></table></figure>
<p>通过上面日志分析得出，PSYoungGen、ParOldGen、PSPermGen属于Parallel收集器。其中PSYoungGen表示gc回收前后年轻代的内存变化；ParOldGen表示gc回收前后老年代的内存变化；PSPermGen表示gc回收前后永久区的内存变化。young
gc 主要是针对年轻代进行内存回收比较频繁，耗时短；full gc
会对整个堆内存进行回城，耗时长，因此一般尽量减少full gc的次数</p>
<p>通过两张图非常明显看出gc日志构成：</p>
<p>Young GC日志:</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702125921.png" alt="微信截图_20230702125921">
<figcaption aria-hidden="true">微信截图_20230702125921</figcaption>
</figure>
<p>Full GC日志:</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702130000.png" alt="微信截图_20230702130000">
<figcaption aria-hidden="true">微信截图_20230702130000</figcaption>
</figure>
<h2 id="gc分析工具">GC分析工具</h2>
<h3 id="gchisto">GChisto</h3>
<p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor
GC、full
gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</p>
<p>配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add
选择gc.log日志</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702130036.png" alt="微信截图_20230702130036">
<figcaption aria-hidden="true">微信截图_20230702130036</figcaption>
</figure>
<p>GC Pause Stats:可以查看GC
的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702130112.png" alt="微信截图_20230702130112">
<figcaption aria-hidden="true">微信截图_20230702130112</figcaption>
</figure>
<p>GC Pause
Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</p>
<p>GC Timeline：显示整个时间线上的垃圾收集</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702130156.png" alt="微信截图_20230702130156">
<figcaption aria-hidden="true">微信截图_20230702130156</figcaption>
</figure>
<p>不过这款工具已经不再维护</p>
<h3 id="gc-easy">GC Easy</h3>
<p>这是一个web工具,在线使用非常方便.</p>
<p>地址: http://gceasy.io</p>
<p>进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702130237.png" alt="微信截图_20230702130237">
<figcaption aria-hidden="true">微信截图_20230702130237</figcaption>
</figure>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%BA%94)Java%20GC%20%E5%88%86%E6%9E%90//微信截图_20230702130259.png" alt="微信截图_20230702130259">
<figcaption aria-hidden="true">微信截图_20230702130259</figcaption>
</figure>
<p>推荐使用此工具进行gc分析。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T18:45:12.000Z" title="2022/3/11 02:45:12">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-02T05:38:42.932Z" title="2023/7/2 13:38:42">2023-07-02</time></span><span class="level-item"><a class="link-muted" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/">JVM调优合集</a></span><span class="level-item">19 minutes read (About 2898 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87/">jvm系列(六):jvm调优-工具篇</a></p><div class="content"><h1 id="jvm系列六jvm调优-工具篇">jvm系列(六):jvm调优-工具篇</h1>
<p>16年的时候花了一些时间整理了一些关于jvm的介绍文章,到现在回顾起来还是一些还没有补充全面，其中就包括如何利用工具来监控调优前后的性能变化。工具做为图形化界面来展示更能直观的发现问题，另一方面一些耗费性能的分析（dump文件分析）一般也不会在生产直接分析，往往dump下来的文件达1G左右，人工分析效率较低，因此利用工具来分析jvm相关问题，长长可以到达事半功倍的效果来。</p>
<p>jvm监控分析工具一般分为两类，一种是jdk自带的工具，一种是第三方的分析工具。jdk自带工具一般在jdk
bin目录下面，以exe的形式直接点击就可以使用，其中包含分析工具已经很强大，几乎涉及了方方面面，但是我们最常使用的只有两款：jconsole.exe和jvisualvm.exe；第三方的分析工具有很多，各自的侧重点不同，比较有代表性的：MAT(Memory
Analyzer Tool)、GChisto等。</p>
<p>对于大型 JAVA
应用程序来说，再精细的测试也难以堵住所有的漏洞，即便我们在测试阶段进行了大量卓有成效的工作，很多问题还是会在生产环境下暴露出来，并且很难在测试环境中进行重现。JVM
能够记录下问题发生时系统的部分运行状态，并将其存储在堆转储 (Heap Dump)
文件中，从而为我们分析和诊断问题提供了重要的依据。其中VisualVM和MAT是dump文件的分析利器。</p>
<h2 id="jdk自带的工具">jdk自带的工具</h2>
<h3 id="jconsole">jconsole</h3>
<p>Jconsole（Java Monitoring and Management
Console）是从java5开始，在JDK中自带的java监控和管理控制台，用于对JVM中内存，线程和类等的监控，是一个基于JMX（java
management
extensions）的GUI性能监测工具。jconsole使用jvm的扩展机制获取并展示虚拟机中运行的应用程序的性能和资源消耗等信息。</p>
<p>直接在jdk/bin目录下点击jconsole.exe即可启动，界面如下:</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131022.png" alt="微信截图_20230702131022">
<figcaption aria-hidden="true">微信截图_20230702131022</figcaption>
</figure>
<p>在弹出的框中可以选择本机的监控本机的java应用，也可以选择远程的java服务来监控，如果监控远程服务需要在tomcat启动脚本中添加如下代码：</p>
<blockquote>
<p>-Dcom.sun.management.jmxremote.port=6969</p>
<p>-Dcom.sun.management.jmxremote.ssl=false</p>
<p>-Dcom.sun.management.jmxremote.authenticate=false</p>
</blockquote>
<p>连接进去之后，就可以看到jconsole概览图和主要的功能：概述、内存、线程、类、VM、MBeans</p>
<ul>
<li>概述，以图表的方式显示出堆内存使用量，活动线程数，已加载的类，CUP占用率的折线图，可以非常清晰的观察在程序执行过程中的变动情况。</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131109.png" alt="微信截图_20230702131109">
<figcaption aria-hidden="true">微信截图_20230702131109</figcaption>
</figure>
<ul>
<li>内存，主要展示了内存的使用情况，同时可以查看堆和非堆内存的变化值对比，也可以点击执行GC来处罚GC的执行</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131138.png" alt="微信截图_20230702131138">
<figcaption aria-hidden="true">微信截图_20230702131138</figcaption>
</figure>
<ul>
<li>线程，主界面展示线程数的活动数和峰值，同时点击左下方线程可以查看线程的详细信息，比如线程的状态是什么，堆栈内容等，同时也可以点击“检测死锁”来检查线程之间是否有死锁的情况。</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131215.png" alt="微信截图_20230702131215">
<figcaption aria-hidden="true">微信截图_20230702131215</figcaption>
</figure>
<ul>
<li>类，主要展示已加载类的相关信息。</li>
<li>VM
概要，展示JVM所有信息总览，包括基本信息、线程相关、堆相关、操作系统、VM参数等。</li>
<li>Mbean,查看Mbean的属性，方法等。</li>
</ul>
<h3 id="visualvm">VisualVM</h3>
<p><strong>简介</strong></p>
<p>VisualVM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机 (Java
Virtual Machine, JVM) 上运行的基于 Java 技术的应用程序（Java
应用程序）的详细信息。VisualVM 对 Java Development Kit (JDK)
工具所检索的 JVM
软件相关数据进行组织，并通过一种使您可以快速查看有关多个 Java
应用程序的数据的方式提供该信息。您可以查看本地应用程序以及远程主机上运行的应用程序的相关数据。此外，还可以捕获有关
JVM
软件实例的数据，并将该数据保存到本地系统，以供后期查看或与其他用户共享。</p>
<p>VisualVM
是javajdk自带的最牛逼的调优工具了吧，也是我平时使用最多调优工具，几乎涉及了jvm调优的方方面面。同样是在jdk/bin目录下面双击jvisualvm.exe既可使用，启动起来后和jconsole
一样同样可以选择本地和远程，如果需要监控远程同样需要配置相关参数，主界面如下；</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131301.png" alt="微信截图_20230702131301">
<figcaption aria-hidden="true">微信截图_20230702131301</figcaption>
</figure>
<p>VisualVM可以根据需要安装不同的插件，每个插件的关注点都不同，有的主要监控GC，有的主要监控内存，有的监控线程等。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131341.png" alt="微信截图_20230702131341">
<figcaption aria-hidden="true">微信截图_20230702131341</figcaption>
</figure>
<p>如何安装：</p>
<blockquote>
<p>1、从主菜单中选择“工具”&gt;“插件”。
2、在“可用插件”标签中，选中该插件的“安装”复选框。单击“安装”。
3、逐步完成插件安装程序。</p>
</blockquote>
<p>我这里以 Eclipse(pid
22296)为例，双击后直接展开，主界面展示了系统和jvm两大块内容，点击右下方jvm参数和系统属性可以参考详细的参数信息.</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131410.png" alt="微信截图_20230702131410">
<figcaption aria-hidden="true">微信截图_20230702131410</figcaption>
</figure>
<p>因为VisualVM的插件太多，我这里主要介绍三个我主要使用几个：监控、线程、Visual
GC</p>
<p>监控的主页其实也就是，cpu、内存、类、线程的图表</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131445.png" alt="微信截图_20230702131445">
<figcaption aria-hidden="true">微信截图_20230702131445</figcaption>
</figure>
<p>线程和jconsole功能没有太大的区别</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131520.png" alt="微信截图_20230702131520">
<figcaption aria-hidden="true">微信截图_20230702131520</figcaption>
</figure>
<p>Visual GC
是常常使用的一个功能，可以明显的看到年轻代、老年代的内存变化，以及gc频率、gc的时间等。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131559.png" alt="微信截图_20230702131559">
<figcaption aria-hidden="true">微信截图_20230702131559</figcaption>
</figure>
<p>以上的功能其实jconsole几乎也有，VisualVM更全面更直观一些，另外VisualVM非常多的其它功能，可以分析dump的内存快照，dump出来的线程快照并且进行分析等，还有其它很多的插件大家可以去探索</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131630.png" alt="微信截图_20230702131630">
<figcaption aria-hidden="true">微信截图_20230702131630</figcaption>
</figure>
<h2 id="第三方调优工具">第三方调优工具</h2>
<h3 id="mat">MAT</h3>
<p><strong>MAT是什么？</strong></p>
<p>MAT(Memory Analyzer
Tool)，一个基于Eclipse的内存分析工具，是一个快速、功能丰富的Java
heap分析工具，它可以帮助我们查找内存泄漏和减少内存消耗。使用内存分析工具从众多的对象中进行分析，快速的计算出在内存中对象的占用大小，看看是谁阻止了垃圾收集器的回收工作，并可以通过报表直观的查看到可能造成这种结果的对象。</p>
<p>通常内存泄露分析被认为是一件很有难度的工作，一般由团队中的资深人士进行。不过要介绍的
MAT（Eclipse Memory
Analyzer）被认为是一个“傻瓜式“的堆转储文件分析工具，你只需要轻轻点击一下鼠标就可以生成一个专业的分析报告。和其他内存泄露分析工具相比，MAT
的使用非常容易，基本可以实现一键到位，即使是新手也能够很快上手使用。</p>
<p>MAT以eclipse
插件的形式来安装，具体的安装过程就不在描述了，可以利用visualvm或者是
jmap命令生产堆文件，导入eclipse mat中生成分析报告：</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131714.png" alt="微信截图_20230702131714">
<figcaption aria-hidden="true">微信截图_20230702131714</figcaption>
</figure>
<p>生产这会报表的同时也会在dump文件的同级目录下生成三份（dump_Top_Consumers.zip、dump_Leak_Suspects.zip、dump_Top_Components.zip）分析结果的html文件，方便发送给相关同事来查看。</p>
<p>需要关注的是下面的Actions、Reports、Step by Step区域：</p>
<ul>
<li>Histogram：列出内存中的对象，对象的个数以及大小，支持正则表达式查找，也可以计算出该类所有对象的retained
size</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131742.png" alt="微信截图_20230702131742">
<figcaption aria-hidden="true">微信截图_20230702131742</figcaption>
</figure>
<ul>
<li>Dominator Tree：列出最大的对象以及其依赖存活的Object
（大小是以Retained Heap为标准排序的）</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131822.png" alt="微信截图_20230702131822">
<figcaption aria-hidden="true">微信截图_20230702131822</figcaption>
</figure>
<ul>
<li>Top Consumers ： 通过图形列出最大的object</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131852.png" alt="微信截图_20230702131852">
<figcaption aria-hidden="true">微信截图_20230702131852</figcaption>
</figure>
<ul>
<li>duplicate classes ：检测由多个类装载器加载的类</li>
<li>Leak Suspects ：内存泄漏分析</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131931.png" alt="微信截图_20230702131931">
<figcaption aria-hidden="true">微信截图_20230702131931</figcaption>
</figure>
<ul>
<li>Top Components: 列出大于总堆数的百分之1的报表。</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702131959.png" alt="微信截图_20230702131959">
<figcaption aria-hidden="true">微信截图_20230702131959</figcaption>
</figure>
<ul>
<li>Component Report:分析对象属于同一个包或者被同一个类加载器加载</li>
</ul>
<p>以上只是一个初级的介绍，mat还有更强大的使用，比如对比堆内存，在生产环境中往往为了定位问题，每隔几分钟dump出一下内存快照，随后在对比不同时间的堆内存的变化来发现问题。</p>
<h3 id="gchisto">GChisto</h3>
<p>GChisto是一款专业分析gc日志的工具，可以通过gc日志来分析：Minor
GC、full
gc的时间、频率等等，通过列表、报表、图表等不同的形式来反应gc的情况。虽然界面略显粗糙，但是功能还是不错的。</p>
<p>配置好本地的jdk环境之后，双击GChisto.jar,在弹出的输入框中点击 add
选择gc.log日志</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702132030.png" alt="微信截图_20230702132030">
<figcaption aria-hidden="true">微信截图_20230702132030</figcaption>
</figure>
<ul>
<li>GC Pause Stats:可以查看GC
的次数、GC的时间、GC的开销、最大GC时间和最小GC时间等，以及相应的柱状图</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702132056.png" alt="微信截图_20230702132056">
<figcaption aria-hidden="true">微信截图_20230702132056</figcaption>
</figure>
<ul>
<li>GC Pause
Distribution:查看GC停顿的详细分布，x轴表示垃圾收集停顿时间，y轴表示是停顿次数。</li>
<li>GC Timeline：显示整个时间线上的垃圾收集</li>
</ul>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702132132.png" alt="微信截图_20230702132132">
<figcaption aria-hidden="true">微信截图_20230702132132</figcaption>
</figure>
<p>不过这款工具已经不再维护，不能识别最新jdk的日志文件。</p>
<h3 id="gcviewer">gcviewer</h3>
<p>GCViewer也是一款分析小工具，用于可视化查看由Sun / Oracle, IBM, HP 和
BEA Java 虚拟机产生的垃圾收集器的日志，gcviewer个人感觉显示
的界面比较乱没有GChisto更专业一些。</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%85%AD)jvm%E8%B0%83%E4%BC%98-%E5%B7%A5%E5%85%B7%E7%AF%87//微信截图_20230702132155.png" alt="微信截图_20230702132155">
<figcaption aria-hidden="true">微信截图_20230702132155</figcaption>
</figure>
<h3 id="gc-easy">GC Easy</h3>
<p>这是一个web工具,在线使用非常方便.</p>
<p>地址: http://gceasy.io</p>
<p>进入官网，讲打包好的zip或者gz为后缀的压缩包上传，过一会就会拿到分析结果。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-10T18:45:12.000Z" title="2022/3/11 02:45:12">2022-03-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-02T05:38:07.043Z" title="2023/7/2 13:38:07">2023-07-02</time></span><span class="level-item"><a class="link-muted" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/">JVM调优合集</a></span><span class="level-item">29 minutes read (About 4397 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%9B%9B)jvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4%E7%AF%87/">jvm系列(四):jvm调优-命令篇</a></p><div class="content"><h1 id="jvm系列四jvm调优-命令篇">jvm系列(四):jvm调优-命令篇</h1>
<p>运用jvm自带的命令可以方便的在生产监控和打印堆栈的日志信息帮忙我们来定位问题！虽然jvm调优成熟的工具已经有很多：jconsole、大名鼎鼎的VisualVM，IBM的Memory
Analyzer等等，但是在生产环境出现问题的时候，一方面工具的使用会有所限制，另一方面喜欢装X的我们，总喜欢在出现问题的时候在终端输入一些命令来解决。所有的工具几乎都是依赖于jdk的接口和底层的这些命令，研究这些命令的使用也让我们更能了解jvm构成和特性。</p>
<p>Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack
jinfo下面做一一介绍</p>
<h2 id="jps">jps</h2>
<p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。</p>
<h3 id="命令格式">命令格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>
<h3 id="option参数">option参数</h3>
<blockquote>
<ul>
<li>-l : 输出主类全名或jar路径</li>
<li>-q : 只输出LVMID</li>
<li>-m : 输出JVM启动时传递给main()的参数</li>
<li>-v : 输出JVM启动时显示指定的JVM参数</li>
</ul>
</blockquote>
<p>其中[option]、[hostid]参数也可以不写。</p>
<h3 id="示例">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jps -l -m  28920 org.apache.catalina.startup.Bootstrap start  11589 org.apache.catalina.startup.Bootstrap start  25816 sun.tools.jps.Jps -l -m</span><br></pre></td></tr></table></figure>
<h2 id="jstat">jstat</h2>
<p>jstat(JVM statistics
Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p>
<h3 id="命令格式-1">命令格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] LVMID [interval] [count]</span><br></pre></td></tr></table></figure>
<h3 id="参数">参数</h3>
<blockquote>
<ul>
<li>[option] : 操作参数</li>
<li>LVMID : 本地虚拟机进程ID</li>
<li>[interval] : 连续输出的时间间隔</li>
<li>[count] : 连续输出的次数</li>
</ul>
</blockquote>
<h4 id="option-参数总览">option 参数总览</h4>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Option</th>
<th style="text-align: left;">Displays…</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">class</td>
<td style="text-align: left;">class loader的行为统计。Statistics on the
behavior of the class loader.</td>
</tr>
<tr class="even">
<td style="text-align: left;">compiler</td>
<td style="text-align: left;">HotSpt JIT编译器行为统计。Statistics of
the behavior of the HotSpot Just-in-Time compiler.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gc</td>
<td style="text-align: left;">垃圾回收堆的行为统计。Statistics of the
behavior of the garbage collected heap.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gccapacity</td>
<td style="text-align: left;">各个垃圾回收代容量(young,old,perm)和他们相应的空间统计。Statistics
of the capacities of the generations and their corresponding
spaces.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gcutil</td>
<td style="text-align: left;">垃圾回收统计概述。Summary of garbage
collection statistics.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gccause</td>
<td style="text-align: left;">垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因。Summary
of garbage collection statistics (same as -gcutil), with the cause of
the last and</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gcnew</td>
<td style="text-align: left;">新生代行为统计。Statistics of the behavior
of the new generation.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gcnewcapacity</td>
<td style="text-align: left;">新生代与其相应的内存空间的统计。Statistics
of the sizes of the new generations and its corresponding spaces.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gcold</td>
<td style="text-align: left;">年老代和永生代行为统计。Statistics of the
behavior of the old and permanent generations.</td>
</tr>
<tr class="even">
<td style="text-align: left;">gcoldcapacity</td>
<td style="text-align: left;">年老代行为统计。Statistics of the sizes of
the old generation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">gcpermcapacity</td>
<td style="text-align: left;">永生代行为统计。Statistics of the sizes of
the permanent generation.</td>
</tr>
<tr class="even">
<td style="text-align: left;">printcompilation</td>
<td style="text-align: left;">HotSpot编译方法统计。HotSpot compilation
method statistics.</td>
</tr>
</tbody>
</table>
<h4 id="option-参数详解">option 参数详解</h4>
<h5 id="class">-class</h5>
<p>监视类装载、卸载数量、总空间以及耗费的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -class 11589 Loaded  Bytes  Unloaded  Bytes     Time     7035  14506.3     0     0.0       3.67</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Loaded : 加载class的数量</li>
<li>Bytes : class字节大小</li>
<li>Unloaded : 未加载class的数量</li>
<li>Bytes : 未加载class的字节大小</li>
<li>Time : 加载时间</li>
</ul>
</blockquote>
<h5 id="compiler">-compiler</h5>
<p>输出JIT编译过的方法数量耗时等</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -compiler 1262Compiled Failed Invalid   Time   FailedType FailedMethod    2573      1       0    47.60          1 org/apache/catalina/loader/WebappClassLoader findResourceInternal  </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Compiled : 编译数量</li>
<li>Failed : 编译失败数量</li>
<li>Invalid : 无效数量</li>
<li>Time : 编译耗时</li>
<li>FailedType : 失败类型</li>
<li>FailedMethod : 失败方法的全限定名</li>
</ul>
</blockquote>
<h5 id="gc">-gc</h5>
<p>垃圾回收堆的行为统计，<strong>常用命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262 S0C    S1C     S0U     S1U   EC       EU        OC         OU        PC       PU         YGC    YGCT    FGC    FGCT     GCT   26112.0 24064.0 6562.5  0.0   564224.0 76274.5   434176.0   388518.3  524288.0 42724.7    320    6.417   1      0.398    6.815</span><br></pre></td></tr></table></figure>
<p><strong>C即Capacity 总容量，U即Used 已使用的容量</strong></p>
<blockquote>
<ul>
<li>S0C : survivor0区的总容量</li>
<li>S1C : survivor1区的总容量</li>
<li>S0U : survivor0区已使用的容量</li>
<li>S1C : survivor1区已使用的容量</li>
<li>EC : Eden区的总容量</li>
<li>EU : Eden区已使用的容量</li>
<li>OC : Old区的总容量</li>
<li>OU : Old区已使用的容量</li>
<li>PC 当前perm的容量 (KB)</li>
<li>PU perm的使用 (KB)</li>
<li>YGC : 新生代垃圾回收次数</li>
<li>YGCT : 新生代垃圾回收时间</li>
<li>FGC : 老年代垃圾回收次数</li>
<li>FGCT : 老年代垃圾回收时间</li>
<li>GCT : 垃圾回收总消耗时间</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gc 1262 2000 20</span><br></pre></td></tr></table></figure>
<p>这个命令意思就是每隔2000ms输出1262的gc情况，一共输出20次</p>
<h5 id="gccapacity">-gccapacity</h5>
<p>同-gc，不过还会输出Java堆各区域使用到的最大、最小空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccapacity 1262 NGCMN    NGCMX     NGC    S0C   S1C       EC         OGCMN      OGCMX      OGC        OC       PGCMN    PGCMX     PGC      PC         YGC    FGC 614400.0 614400.0 614400.0 26112.0 24064.0 564224.0   434176.0   434176.0   434176.0   434176.0 524288.0 1048576.0 524288.0 524288.0    320     1  </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>NGCMN : 新生代占用的最小空间</li>
<li>NGCMX : 新生代占用的最大空间</li>
<li>OGCMN : 老年代占用的最小空间</li>
<li>OGCMX : 老年代占用的最大空间</li>
<li>OGC：当前年老代的容量 (KB)</li>
<li>OC：当前年老代的空间 (KB)</li>
<li>PGCMN : perm占用的最小空间</li>
<li>PGCMX : perm占用的最大空间</li>
</ul>
</blockquote>
<h5 id="gcutil">-gcutil</h5>
<p>同-gc，不过输出的是已使用空间占总空间的百分比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcutil 28920  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT    12.45   0.00  33.85   0.00   4.44  4       0.242     0    0.000    0.242</span><br></pre></td></tr></table></figure>
<h5 id="gccause">-gccause</h5>
<p>垃圾收集统计概述（同-gcutil），附加最近两次垃圾回收事件的原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gccause 28920  S0     S1     E      O      P       YGC     YGCT    FGC    FGCT     GCT    LGCC                 GCC                  12.45   0.00  33.85   0.00   4.44      4    0.242     0    0.000    0.242   Allocation Failure   No GC  </span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>LGCC：最近垃圾回收的原因</li>
<li>GCC：当前垃圾回收的原因</li>
</ul>
</blockquote>
<h5 id="gcnew">-gcnew</h5>
<p>统计新生代的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnew 28920 S0C      S1C      S0U        S1U  TT  MTT  DSS      EC        EU         YGC     YGCT   419392.0 419392.0 52231.8    0.0  6   6    209696.0 3355520.0 1172246.0  4       0.242</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>TT：Tenuring threshold(提升阈值)</li>
<li>MTT：最大的tenuring threshold</li>
<li>DSS：survivor区域大小 (KB)</li>
</ul>
</blockquote>
<h5 id="gcnewcapacity">-gcnewcapacity</h5>
<p>新生代与其相应的内存空间的统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcnewcapacity 28920  NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX        EC        YGC   FGC  4194304.0  4194304.0  4194304.0 419392.0 419392.0 419392.0 419392.0  3355520.0  3355520.0     4     0</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>NGC:当前年轻代的容量 (KB)</li>
<li>S0CMX:最大的S0空间 (KB)</li>
<li>S0C:当前S0空间 (KB)</li>
<li>ECMX:最大eden空间 (KB)</li>
<li>EC:当前eden空间 (KB)</li>
</ul>
</blockquote>
<h5 id="gcold">-gcold</h5>
<p>统计旧生代的行为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcold 28920   PC       PU        OC           OU       YGC    FGC    FGCT     GCT   1048576.0  46561.7   6291456.0     0.0      4      0      0.000    0.242</span><br></pre></td></tr></table></figure>
<h5 id="gcoldcapacity">-gcoldcapacity</h5>
<p>统计旧生代的大小和空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcoldcapacity 28920   OGCMN       OGCMX        OGC         OC         YGC   FGC    FGCT     GCT     6291456.0   6291456.0   6291456.0   6291456.0     4     0    0.000    0.242</span><br></pre></td></tr></table></figure>
<h5 id="gcpermcapacity">-gcpermcapacity</h5>
<p>永生代行为统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -gcpermcapacity 28920    PGCMN      PGCMX       PGC         PC      YGC   FGC    FGCT     GCT    1048576.0  2097152.0  1048576.0  1048576.0     4     0    0.000    0.242</span><br></pre></td></tr></table></figure>
<h5 id="printcompilation">-printcompilation</h5>
<p>hotspot编译方法统计</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstat -printcompilation 28920    Compiled  Size  Type Method    1291      78     1    java/util/ArrayList indexOf</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>Compiled：被执行的编译任务的数量</li>
<li>Size：方法字节码的字节数</li>
<li>Type：编译类型</li>
<li>Method：编译方法的类名和方法名。类名使用"/" 代替 "." 作为空间分隔符.
方法名是给出类的方法名. 格式是一致于HotSpot - XX:+PrintComplation
选项</li>
</ul>
</blockquote>
<h2 id="jmap">jmap</h2>
<p>jmap(JVM Memory Map)命令用于生成heap
dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。
jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。</p>
<h3 id="命令格式-2">命令格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] LVMID</span><br></pre></td></tr></table></figure>
<h3 id="option参数-1">option参数</h3>
<blockquote>
<ul>
<li>dump : 生成堆转储快照</li>
<li>finalizerinfo :
显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li>
<li>heap : 显示Java堆详细信息</li>
<li>histo : 显示堆中对象的统计信息</li>
<li>permstat : to print permanent generation statistics</li>
<li>F : 当-dump没有响应时，强制生成dump快照</li>
</ul>
</blockquote>
<h3 id="示例-1">示例</h3>
<h5 id="dump">-dump</h5>
<p>常用格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dump::live,format=b,file=&lt;filename&gt; pid </span><br></pre></td></tr></table></figure>
<p>dump堆到文件,format指定输出格式，live指明是活着的对象,file指定文件名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -dump:live,format=b,file=dump.hprof 28920  Dumping heap to /home/xxx/dump.hprof ...  Heap dump file created</span><br></pre></td></tr></table></figure>
<p>dump.hprof这个后缀是为了后续可以直接用MAT(Memory Anlysis
Tool)打开。</p>
<h5 id="finalizerinfo">-finalizerinfo</h5>
<p>打印等待回收对象的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -finalizerinfo 28920  Attaching to process ID 28920, please wait...  Debugger attached successfully.  Server compiler detected.  JVM version is 24.71-b01  Number of objects pending for finalization: 0</span><br></pre></td></tr></table></figure>
<p>可以看到当前F-QUEUE队列中并没有等待Finalizer线程执行finalizer方法的对象。</p>
<h5 id="heap">-heap</h5>
<p>打印heap的概要信息，GC使用的算法，heap的配置及wise
heap的使用情况,可以用此来判断内存目前的使用情况以及垃圾回收情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -heap 28920  Attaching to process ID 28920, please wait...  Debugger attached successfully.  Server compiler detected.  JVM version is 24.71-b01    using thread-local object allocation.  Parallel GC with 4 thread(s)//GC 方式    Heap Configuration: //堆内存初始化配置     MinHeapFreeRatio = 0 //对应jvm启动参数-XX:MinHeapFreeRatio设置JVM堆最小空闲比率(default 40)     MaxHeapFreeRatio = 100 //对应jvm启动参数 -XX:MaxHeapFreeRatio设置JVM堆最大空闲比率(default 70)     MaxHeapSize      = 2082471936 (1986.0MB) //对应jvm启动参数-XX:MaxHeapSize=设置JVM堆的最大大小     NewSize          = 1310720 (1.25MB)//对应jvm启动参数-XX:NewSize=设置JVM堆的‘新生代’的默认大小     MaxNewSize       = 17592186044415 MB//对应jvm启动参数-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小     OldSize          = 5439488 (5.1875MB)//对应jvm启动参数-XX:OldSize=&lt;value&gt;:设置JVM堆的‘老生代’的大小     NewRatio         = 2 //对应jvm启动参数-XX:NewRatio=:‘新生代’和‘老生代’的大小比率     SurvivorRatio    = 8 //对应jvm启动参数-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值      PermSize         = 21757952 (20.75MB)  //对应jvm启动参数-XX:PermSize=&lt;value&gt;:设置JVM堆的‘永生代’的初始大小     MaxPermSize      = 85983232 (82.0MB)//对应jvm启动参数-XX:MaxPermSize=&lt;value&gt;:设置JVM堆的‘永生代’的最大大小     G1HeapRegionSize = 0 (0.0MB)    Heap Usage://堆内存使用情况  PS Young Generation  Eden Space://Eden区内存分布     capacity = 33030144 (31.5MB)//Eden区总容量     used     = 1524040 (1.4534378051757812MB)  //Eden区已使用     free     = 31506104 (30.04656219482422MB)  //Eden区剩余容量     4.614088270399305% used //Eden区使用比率  From Space:  //其中一个Survivor区的内存分布     capacity = 5242880 (5.0MB)     used     = 0 (0.0MB)     free     = 5242880 (5.0MB)     0.0% used  To Space:  //另一个Survivor区的内存分布     capacity = 5242880 (5.0MB)     used     = 0 (0.0MB)     free     = 5242880 (5.0MB)     0.0% used  PS Old Generation //当前的Old区内存分布     capacity = 86507520 (82.5MB)     used     = 0 (0.0MB)     free     = 86507520 (82.5MB)     0.0% used  PS Perm Generation//当前的 “永生代” 内存分布     capacity = 22020096 (21.0MB)     used     = 2496528 (2.3808746337890625MB)     free     = 19523568 (18.619125366210938MB)     11.337498256138392% used    670 interned Strings occupying 43720 bytes.</span><br></pre></td></tr></table></figure>
<p>可以很清楚的看到Java堆中各个区域目前的情况。</p>
<h5 id="histo">-histo</h5>
<p>打印堆的对象统计，包括对象数、内存大小等等
（因为在dump:live前会进行full
gc，如果带上live则只统计活对象，因此不加live的堆大小要大于加live堆的大小
）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo:live 28920 | more num     #instances         #bytes  class name----------------------------------------------   1:         83613       12012248  &lt;constMethodKlass&gt;   2:         23868       11450280  [B   3:         83613       10716064  &lt;methodKlass&gt;   4:         76287       10412128  [C   5:          8227        9021176  &lt;constantPoolKlass&gt;   6:          8227        5830256  &lt;instanceKlassKlass&gt;   7:          7031        5156480  &lt;constantPoolCacheKlass&gt;   8:         73627        1767048  java.lang.String   9:          2260        1348848  &lt;methodDataKlass&gt;  10:          8856         849296  java.lang.Class  ....</span><br></pre></td></tr></table></figure>
<p>仅仅打印了前10行</p>
<p>xml class name是对象类型，说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B  byteC  charD  doubleF  floatI  intJ  longZ  boolean[  数组，如[I表示int[][L+类名 其他对象</span><br></pre></td></tr></table></figure>
<h5 id="permstat">-permstat</h5>
<p>打印Java堆内存的永久保存区域的类加载器的智能统计信息。对于每个类加载器而言，它的名称、活跃度、地址、父类加载器、它所加载的类的数量和大小都会被打印。此外，包含的字符串数量和大小也会被打印。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -permstat 28920  Attaching to process ID 28920, please wait...  Debugger attached successfully.  Server compiler detected.  JVM version is 24.71-b01  finding class loader instances ..done.  computing per loader stat ..done.  please wait.. computing liveness.liveness analysis may be inaccurate ...  class_loader            classes bytes   parent_loader           alive?  type    &lt;bootstrap&gt;             3111    18154296          null          live    &lt;internal&gt;  0x0000000600905cf8      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0  0x00000006008fcb48      1       1888    0x0000000600087f08      dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0  0x00000006016db798      0       0       0x00000006008d3fc0      dead    java/util/ResourceBundle$RBClassLoader@0x0000000780626ec0  0x00000006008d6810      1       3056      null          dead    sun/reflect/DelegatingClassLoader@0x00000007800500a0</span><br></pre></td></tr></table></figure>
<h5 id="f">-F</h5>
<p>强制模式。如果指定的pid没有响应，请使用jmap -dump或jmap
-histo选项。此模式下，不支持live子选项。</p>
<h2 id="jhat">jhat</h2>
<p>jhat(JVM Heap Analysis
Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。</p>
<h3 id="命令格式-3">命令格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jhat [dumpfile]</span><br></pre></td></tr></table></figure>
<h3 id="参数-1">参数</h3>
<blockquote>
<ul>
<li>-stack false|true 关闭对象分配调用栈跟踪(tracking object allocation
call stack)。 如果分配位置信息在堆转储中不可用. 则必须将此标志设置为
false. 默认值为 true.&gt;</li>
<li>-refs false|true 关闭对象引用跟踪(tracking of references to
objects)。 默认值为 true. 默认情况下,
返回的指针是指向其他特定对象的对象,如反向链接或输入引用(referrers or
incoming references), 会统计/计算堆中的所有对象。&gt;</li>
<li>-port port-number 设置 jhat HTTP server 的端口号. 默认值
7000.&gt;</li>
<li>-exclude exclude-file 指定对象查询时需要排除的数据成员列表文件(a
file that lists data members that should be excluded from the reachable
objects query)。 例如, 如果文件列列出了 java.lang.String.value ,
那么当从某个特定对象 Object o 计算可达的对象列表时, 引用路径涉及
java.lang.String.value 的都会被排除。&gt;</li>
<li>-baseline exclude-file 指定一个基准堆转储(baseline heap dump)。
在两个 heap dumps 中有相同 object ID 的对象会被标记为不是新的(marked as
not being new). 其他对象被标记为新的(new).
在比较两个不同的堆转储时很有用.&gt;</li>
<li>-debug int 设置 debug 级别. 0 表示不输出调试信息。
值越大则表示输出更详细的 debug 信息.&gt;</li>
<li>-version 启动后只显示版本信息就退出&gt;</li>
<li>-J&lt; flag &gt; 因为 jhat 命令实际上会启动一个JVM来执行, 通过 -J
可以在启动JVM时传入一些启动参数. 例如, -J-Xmx512m 则指定运行 jhat
的Java虚拟机使用的最大堆内存为 512 MB.
如果需要使用多个JVM启动参数,则传入多个 -Jxxxxxx.</li>
</ul>
</blockquote>
<h3 id="示例-2">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jhat -J-Xmx512m dump.hprof  eading from dump.hprof...  Dump file created Fri Mar 11 17:13:42 CST 2016  Snapshot read, resolving...  Resolving 271678 objects...  Chasing references, expect 54 dots......................................................  Eliminating duplicate references......................................................  Snapshot resolved.  Started HTTP server on port 7000  Server is ready.</span><br></pre></td></tr></table></figure>
<p>中间的-J-Xmx512m是在dump快照很大的情况下分配512M内存去启动HTTP服务器，运行完之后就可在浏览器打开Http://localhost:7000进行快照分析
堆快照分析主要在最后面的Heap
Histogram里，里面根据class列出了dump的时候所有存活对象。</p>
<p><strong>分析同样一个dump快照，MAT需要的额外内存比jhat要小的多的多，所以建议使用MAT来进行分析，当然也看个人偏好。</strong></p>
<h3 id="分析">分析</h3>
<p>打开浏览器Http://localhost:7000，该页面提供了几个查询功能可供使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All classes including platformShow all members of the rootsetShow instance counts for all classes (including platform)Show instance counts for all classes (excluding platform)Show heap histogramShow finalizer summaryExecute Object Query Language (OQL) query</span><br></pre></td></tr></table></figure>
<p>一般查看堆异常情况主要看这个两个部分： Show instance counts for all
classes (excluding platform)，平台外的所有对象信息。如下图：</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%9B%9B)jvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4%E7%AF%87//微信截图_20230702130632.png" alt="微信截图_20230702130632">
<figcaption aria-hidden="true">微信截图_20230702130632</figcaption>
</figure>
<p>Show heap histogram 以树状图形式展示堆情况。如下图：</p>
<figure>
<img src="/2022/03/11/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E5%9B%9B)jvm%E8%B0%83%E4%BC%98-%E5%91%BD%E4%BB%A4%E7%AF%87//微信截图_20230702130713.png" alt="微信截图_20230702130713">
<figcaption aria-hidden="true">微信截图_20230702130713</figcaption>
</figure>
<p>具体排查时需要结合代码，观察是否大量应该被回收的对象在一直被引用或者是否有占用内存特别大的对象无法被回收。
<strong>一般情况，会down到客户端用工具来分析</strong></p>
<h2 id="jstack">jstack</h2>
<p>jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。
线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java
stack和native
stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java
stack和native stack的信息,
如果现在运行的java程序呈现hung的状态，jstack是非常有用的。</p>
<h3 id="命令格式-4">命令格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] LVMID</span><br></pre></td></tr></table></figure>
<h3 id="option参数-2">option参数</h3>
<blockquote>
<ul>
<li>-F : 当正常输出请求不被响应时，强制输出线程堆栈</li>
<li>-l : 除堆栈外，显示关于锁的附加信息</li>
<li>-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</li>
</ul>
</blockquote>
<h3 id="示例-3">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jstack -l 11494|more2016-07-28 13:40:04Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.71-b01 mixed mode):&quot;Attach Listener&quot; daemon prio=10 tid=0x00007febb0002000 nid=0x6b6f waiting on condition [0x0000000000000000]   java.lang.Thread.State: RUNNABLE   Locked ownable synchronizers:        - None&quot;http-bio-8005-exec-2&quot; daemon prio=10 tid=0x00007feb94028000 nid=0x7b8c waiting on condition [0x00007fea8f56e000]   java.lang.Thread.State: WAITING (parking)        at sun.misc.Unsafe.park(Native Method)        - parking to wait for  &lt;0x00000000cae09b80&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2043)        at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:442)        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:104)        at org.apache.tomcat.util.threads.TaskQueue.take(TaskQueue.java:32)        at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:1068)        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)        at java.lang.Thread.run(Thread.java:745)   Locked ownable synchronizers:        - None      .....</span><br></pre></td></tr></table></figure>
<h3 id="分析-1">分析</h3>
<p>这里有一篇文章解释的很好 分析打印出的文件内容</p>
<h2 id="jinfo">jinfo</h2>
<p>jinfo(JVM Configuration
info)这个命令作用是实时查看和调整虚拟机运行参数。 之前的jps
-v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</p>
<h3 id="命令格式-5">命令格式</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] [args] LVMID</span><br></pre></td></tr></table></figure>
<h3 id="option参数-3">option参数</h3>
<blockquote>
<ul>
<li>-flag : 输出指定args参数的值</li>
<li>-flags : 不需要args参数，输出所有JVM参数的值</li>
<li>-sysprops : 输出系统属性，等同于System.getProperties()</li>
</ul>
</blockquote>
<h3 id="示例-4">示例</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jinfo -flag 11494-XX:CMSInitiatingOccupancyFraction=80</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-09T18:45:12.000Z" title="2022/3/10 02:45:12">2022-03-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-07-02T05:31:45.016Z" title="2023/7/2 13:31:45">2023-07-02</time></span><span class="level-item"><a class="link-muted" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/">JVM调优合集</a></span><span class="level-item">34 minutes read (About 5163 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="../../2022/03/10/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%80)java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/">jvm系列(一):java类的加载机制</a></p><div class="content"><h1 id="一jvm系列一java类的加载机制">一，jvm系列(一):java类的加载机制</h1>
<h2 id="什么是类的加载">1、什么是类的加载</h2>
<p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个
<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的
<code>Class</code>对象，
<code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<figure>
<img src="/2022/03/10/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%80)java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6//微信截图_20230702120310.png" alt="微信截图_20230702120310">
<figcaption aria-hidden="true">微信截图_20230702120310</figcaption>
</figure>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<p><strong>加载.class文件的方式</strong></p>
<ul>
<li>从本地系统中直接加载</li>
<li>通过网络下载.class文件</li>
<li>从zip，jar等归档文件中加载.class文件</li>
<li>从专有数据库中提取.class文件</li>
<li>将Java源文件动态编译为.class文件</li>
</ul>
<h2 id="类的生命周期">2、类的生命周期</h2>
<p>其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="加载">加载</h3>
<p>查找并加载类的二进制数据加载时类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：</p>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的
<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个
<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="连接">连接</h3>
<p><strong>验证：确保被加载的类的正确性</strong></p>
<p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ul>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范；例如：是否以
<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了
<code>java.lang.Object</code>之外。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>
</ul>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用
<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<p><strong>准备：为类的
<code>静态变量分</code>配内存，并将其初始化为默认值</strong></p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<ul>
<li>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为： <code>publicstaticintvalue=3</code>；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的
<code>publicstatic</code>指令是在程序编译后，存放于类构造器
<code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<blockquote>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。</li>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</blockquote>
<ul>
<li>3、如果类字段的字段属性表中存在
<code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li>
</ul>
<p>假设上面的类变量value被定义为：
<code>publicstaticfinalintvalue=3</code>；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据
<code>ConstantValue</code>的设置将value赋值为3。我们可以理解为static
final常量在编译期就将其结果放入了调用它的类的常量池中</p>
<p><strong>解析：把类中的符号引用转换为直接引用</strong></p>
<p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<p><strong>初始化</strong></p>
<p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>①声明类变量是指定初始值</li>
<li>②使用静态代码块为类变量指定初始值</li>
</ul>
<p>JVM初始化步骤</p>
<ul>
<li>1、假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>3、假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ul>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：</p>
<ul>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 <code>Class.forName(“com.shengsiyuan.Test”)</code>）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（
<code>JavaTest</code>），直接使用
<code>java.exe</code>命令来运行某个主类</li>
</ul>
<p><strong>结束生命周期</strong></p>
<p>在如下几种情况下，Java虚拟机将结束生命周期</p>
<ul>
<li>执行了 <code>System.exit()</code>方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
<h2 id="类加载器">3、类加载器</h2>
<p>寻找类加载器，先来一个小例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.neo.classloader;public class ClassLoaderTest &#123;     public static void main(String[] args) &#123;        ClassLoader loader = Thread.currentThread().getContextClassLoader();        System.out.println(loader);        System.out.println(loader.getParent());        System.out.println(loader.getParent().getParent());    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>运行后，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sun.misc.Launcher$AppClassLoader@64fef26asun.misc.Launcher$ExtClassLoader@1ddd40f3null</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看出，并没有获取到
<code>ExtClassLoader</code>的父Loader，原因是
<code>BootstrapLoader</code>（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p>
<p>这几种类加载器的层次关系如下图所示：</p>
<figure>
<img src="/2022/03/10/JVM/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/jvm%E7%B3%BB%E5%88%97(%E4%B8%80)java%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6//微信截图_20230702121042.png" alt="微信截图_20230702121042">
<figcaption aria-hidden="true">微信截图_20230702121042</figcaption>
</figure>
<blockquote>
<p>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。</p>
</blockquote>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其它的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类
<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p><strong>启动类加载器</strong>：
<code>BootstrapClassLoader</code>，负责加载存放在
<code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被
<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被
<code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。
<strong>扩展类加载器</strong>：
<code>ExtensionClassLoader</code>，该加载器由
<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载
<code>JDK\jre\lib\ext</code>目录中，或者由
<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。
<strong>应用程序类加载器</strong>：
<code>ApplicationClassLoader</code>，该类加载器由
<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java
class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<ul>
<li>1、在执行非置信代码之前，自动验证数字签名。</li>
<li>2、动态地创建符合用户特定需要的定制化构建类。</li>
<li>3、从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<p><strong>JVM类加载机制</strong></p>
<ul>
<li><strong>全盘负责</strong>，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入</li>
<li><strong>父类委托</strong>，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类</li>
<li><strong>缓存机制</strong>，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</li>
</ul>
<h2 id="类的加载">4、类的加载</h2>
<p>类加载有三种方式：</p>
<ul>
<li>1、命令行启动应用时候由JVM初始化加载</li>
<li>2、通过Class.forName()方法动态加载</li>
<li>3、通过ClassLoader.loadClass()方法动态加载</li>
</ul>
<p>例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.neo.classloader;public class loaderTest &#123;         public static void main(String[] args) throws ClassNotFoundException &#123;                 ClassLoader loader = HelloWorld.class.getClassLoader();                 System.out.println(loader);                 //使用ClassLoader.loadClass()来加载类，不会执行初始化块                 loader.loadClass(&quot;Test2&quot;);                 //使用Class.forName()来加载类，默认会执行初始化块                 //Class.forName(&quot;Test2&quot;);                 //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块                 //Class.forName(&quot;Test2&quot;, false, loader);         &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>demo类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Test2 &#123;         static &#123;                 System.out.println(&quot;静态初始化块执行了！&quot;);         &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>分别切换加载方式，会有不同的输出结果。</p>
<p><strong>Class.forName()和ClassLoader.loadClass()区别</strong></p>
<ul>
<li><code>Class.forName()</code>：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li><code>ClassLoader.loadClass()</code>：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li><code>Class.forName(name,initialize,loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象
。</li>
</ul>
<h2 id="双亲委派模型">5、双亲委派模型</h2>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>双亲委派机制:</p>
<ul>
<li>1、当
<code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li>
<li>2、当
<code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</li>
<li>3、如果 <code>BootStrapClassLoader</code>加载失败（例如在
<code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用
<code>ExtClassLoader</code>来尝试加载；</li>
<li>4、若ExtClassLoader也加载失败，则会使用
<code>AppClassLoader</code>来加载，如果
<code>AppClassLoader</code>也加载失败，则会报出异常
<code>ClassNotFoundException</code>。</li>
</ul>
<p>ClassLoader源码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;        return loadClass(name, false);&#125;protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;        // 首先判断该类型是否已经被加载        Class c = findLoadedClass(name);        if (c == null) &#123;            //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载            try &#123;                if (parent != null) &#123;                     //如果存在父类加载器，就委派给父类加载器加载                    c = parent.loadClass(name, false);                &#125; else &#123;                //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)                    c = findBootstrapClass0(name);                &#125;            &#125; catch (ClassNotFoundException e) &#123;             // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能                c = findClass(name);            &#125;        &#125;        if (resolve) &#123;            resolveClass(c);        &#125;        return c;    &#125;</span><br></pre></td></tr></table></figure>
<p>双亲委派模型意义：</p>
<ul>
<li>系统类防止内存中出现多份同样的字节码</li>
<li>保证Java程序安全稳定运行</li>
</ul>
<h2 id="自定义类加载器">6、自定义类加载器</h2>
<p>通常情况下，我们都是直接使用系统类加载器。但是，有的时候，我们也需要自定义类加载器。比如应用是通过网络来传输
Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自
<code>ClassLoader</code>类，从上面对
<code>loadClass</code>方法来分析来看，我们只需要重写 findClass
方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.neo.classloader;import java.io.*;public class MyClassLoader extends ClassLoader &#123;    private String root;    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;        byte[] classData = loadClassData(name);        if (classData == null) &#123;            throw new ClassNotFoundException();        &#125; else &#123;            return defineClass(name, classData, 0, classData.length);        &#125;    &#125;    private byte[] loadClassData(String className) &#123;        String fileName = root + File.separatorChar                + className.replace(&#x27;.&#x27;, File.separatorChar) + &quot;.class&quot;;        try &#123;            InputStream ins = new FileInputStream(fileName);            ByteArrayOutputStream baos = new ByteArrayOutputStream();            int bufferSize = 1024;            byte[] buffer = new byte[bufferSize];            int length = 0;            while ((length = ins.read(buffer)) != -1) &#123;                baos.write(buffer, 0, length);            &#125;            return baos.toByteArray();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;    public String getRoot() &#123;        return root;    &#125;    public void setRoot(String root) &#123;        this.root = root;    &#125;    public static void main(String[] args)  &#123;        MyClassLoader classLoader = new MyClassLoader();        classLoader.setRoot(&quot;E:\\temp&quot;);        Class&lt;?&gt; testClass = null;        try &#123;            testClass = classLoader.loadClass(&quot;com.neo.classloader.Test2&quot;);            Object object = testClass.newInstance();            System.out.println(object.getClass().getClassLoader());        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (InstantiationException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p>
<ul>
<li>1、这里传递的文件名需要是类的全限定性名称，即
<code>com.paddx.test.classloading.Test</code>格式的，因为 defineClass
方法是按这种格式进行处理的。</li>
<li>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</li>
<li>3、这类Test 类本身可以被
<code>AppClassLoader</code>类加载，因此我们不能把
<code>com/paddx/test/classloading/Test.class</code>放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由
<code>AppClassLoader</code>加载，而不会通过我们自定义类加载器来加载。</li>
</ul>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="../../">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="../3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="../../">1</a></li><li><a class="pagination-link is-current" href="">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="../../img/avatar.png" alt="albert"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">albert</p><p class="is-size-6 is-block">albert</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>shanghai</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="../../archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="../../categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="../../tags"><p class="title">0</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/0914ds" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="../../index.html"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../categories/JVM%E8%B0%83%E4%BC%98%E5%90%88%E9%9B%86/"><span class="level-start"><span class="level-item">JVM调优合集</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="../../categories/%E5%AE%B9%E5%99%A8/"><span class="level-start"><span class="level-item">容器</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="../../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="level-start"><span class="level-item">机器学习</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="../../categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="level-start"><span class="level-item">消息中间件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-17T17:13:16.000Z">2023-08-18</time></p><p class="title"><a href="../../2023/08/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/">多元线性回归</a></p><p class="categories"><a href="../../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-17T05:13:16.000Z">2023-08-17</time></p><p class="title"><a href="../../2023/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/">多元线性回归</a></p><p class="categories"><a href="../../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-08-16T17:30:16.000Z">2023-08-17</time></p><p class="title"><a href="../../2023/08/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/3-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E4%BC%98%E5%8C%96/">梯度下降优化</a></p><p class="categories"><a href="../../categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-17T06:13:16.000Z">2023-06-17</time></p><p class="title"><a href="../../2023/06/17/%E6%B6%88%E6%81%AF/kafka/">kafka</a></p><p class="categories"><a href="../../categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/">消息中间件</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-06-05T07:02:29.235Z">2023-06-05</time></p><p class="title"><a href="../../2023/06/05/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/mysql%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/">mysql的锁机制</a></p><p class="categories"><a href="../../categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="../../archives/2023/08/"><span class="level-start"><span class="level-item">August 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="../../archives/2023/06/"><span class="level-start"><span class="level-item">June 2023</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="../../archives/2023/05/"><span class="level-start"><span class="level-item">May 2023</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="../../archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></div></div></div><!--!--></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="../../index.html"><img src="../../img/logo.svg" alt="blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 albert dong</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="../../js/column.js"></script><script src="../../js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="../../js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="../../js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="../../js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"../../content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>