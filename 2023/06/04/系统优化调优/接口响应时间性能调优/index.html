<!DOCTYPE html>
<html lang="en">
    
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <meta name="description" content="容器的演进发展" />
    <meta name="hexo-theme-A4" content="v1.9.7" />
    <link rel="alternate icon" type="image/webp" href="../../../../../img/favicon.webp">
    <title>blog</title>

    
        
<link rel="stylesheet" href="../../../../../css/highlight/style1.css">

        
<link rel="stylesheet" href="../../../../../css/reset.css">

        
<link rel="stylesheet" href="../../../../../css/markdown.css">

        
<link rel="stylesheet" href="../../../../../css/fonts.css">
 
         <!--注意：首页既不是post也不是page-->
        
        
        
<link rel="stylesheet" href="../../../../../css/ui.css">
 
        
<link rel="stylesheet" href="../../../../../css/style.css">


        
            <!--返回顶部css-->
            
<link rel="stylesheet" href="../../../../../css/returnToTop.css">

            
<link rel="stylesheet" href="../../../../../css/unicons.css">

        
        
            <!--目录-->
            
<link rel="stylesheet" href="../../../../../css/toc.css">

        
    

    
        
<link rel="stylesheet" href="../../../../../css/returnToLastPage.css">

    
    
   
<link rel="stylesheet" href="../../../../../css/lightgallery-bundle.min.css">


   
        
<link rel="stylesheet" href="../../../../../css/custom.css">

    

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="atom.xml" title="blog" type="application/atom+xml">
</head>
    
    
        <style>
            .index-main{
                max-width:  880px;
            }
        </style>

    
    



    

    
    




    
    
    
    <body>
        <script src="/js/darkmode-js.min.js"></script>
        
        <script>
            const options = {
                bottom: '40px', // default: '32px'
                right: 'unset', // default: '32px'
                left: '42px', // default: 'unset'
                time: '0.3s', // default: '0.3s'
                mixColor: '#fff', // default: '#fff'
                backgroundColor: ' #e4e4e4 ',  // default: '#fff'
                buttonColorDark: '#100f2c',  // default: '#100f2c'
                buttonColorLight: '#fff', // default: '#fff'
                saveInCookies: true, // default: true,
                label: '🌓', // default: ''
                autoMatchOsTheme: true // default: true
            }
            const darkmode = new Darkmode(options);
            darkmode.showWidget();
        </script>
        
        
            <div class="left-toc-container">
                <nav id="toc" class="bs-docs-sidebar"></nav>
            </div>
        
        <div class="paper">
            
            
            
            
                <div class="shadow-drop-2-bottom paper-main">
                    


<div class="header">
    <div class="header-container">
        <style>
            .header-img {
                width: 56px;
                height: auto;
                object-fit: cover; /* 保持图片比例 */
                transition: transform 0.3s ease-in-out; 
                border-radius: 0; 
            }
            
        </style>
        <img 
            alt="^-^" 
            cache-control="max-age=86400" 
            class="header-img" 
            src="../../../../../img/favicon.webp" 
        />
        <div class="header-content">
            <a class="logo" href="../../../../../index.html">blog</a> 
            <span class="description"></span> 
        </div>
    </div>
    
   
    <ul class="nav">
        
            
                <li><a href="../../../../../index.html">首页</a></li>
            
        
            
                <li><a href="../../../../../list/">文章</a></li>
            
        
            
                <li><a href="../../../../../about/">关于</a></li>
            
        
            
                <li><a href="../../../../../tags/">标签</a></li>
            
        
    </ul>
</div> 
        
                    
                    

                    
                    
                    
                    <!--说明是文章post页面-->
                    
                        <div class="post-main">
    

    
        
            
                <div class="post-main-title" style="text-align: center;">
                    容器的演进发展
                </div>
            
        
      
    

    

        
            <div class="post-head-meta-center">
        
                
                    <span>最近更新：2024-02-24</span> 
                
                
                    
                        &nbsp; | &nbsp;
                    
                     <span>字数总计：9.3k</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span>阅读估时：34分钟</span>
                
                
                    
                        &nbsp; | &nbsp;
                    
                    <span id="busuanzi_container_page_pv">
                        阅读量：<span id="busuanzi_value_page_pv"></span>次
                    </span>
                
            </div>
    

    <div class="post-md">
        
            
                <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%94%A8%E6%88%B7%E4%B8%AD%E5%8F%B0%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E5%B8%B8%E8%A7%84%E6%80%9D%E8%B7%AF"><span class="post-toc-text">用户中台性能优化的常规思路</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E8%BD%AE%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E4%BC%98%E5%8C%96%E6%8F%90%E5%8D%8760%E5%80%8D"><span class="post-toc-text">第一轮优化：数据库层面优化，提升60倍</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%98%E5%8C%96%E6%8F%90%E5%8D%8770%E5%80%8D"><span class="post-toc-text">第二步：应用层优化，提升70倍</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5bigkey%E9%97%AE%E9%A2%98%E4%BC%98%E5%8C%964000%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E5%88%B0100ms"><span class="post-toc-text">第四步：BigKey问题优化，4000并发场景到100ms</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E4%BC%98%E5%8C%96%E5%88%B020ms"><span class="post-toc-text">第五步：本地缓存优化，优化到20ms</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%AC%AC%E5%85%AD%E6%AD%A5%E7%BD%91%E5%85%B3%E5%B1%82%E9%9D%A2%E7%9A%84%E4%BC%98%E5%8C%96"><span class="post-toc-text">第六步：网关层面的优化</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80.%E5%90%AF%E7%94%A8%E4%BB%A3%E7%90%86%E7%BC%93%E5%AD%98"><span class="post-toc-text">一.启用代理缓存：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BB%8E70s%E5%88%B020ms%E8%B0%83%E4%BC%98%E5%B0%8F%E7%BB%93"><span class="post-toc-text">从70s到20ms调优小结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8application%E9%83%A8%E7%BD%B2%E5%AE%B9%E5%99%A8%E5%8C%96%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF"><span class="post-toc-text">应用（Application）部署容器化演进之路</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%80%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E7%97%9B%E7%82%B9"><span class="post-toc-text">一、应用程序部署痛点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%83%A8%E7%BD%B2%E6%B5%81%E7%A8%8B"><span class="post-toc-text">1.1 应用程序部署流程</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="post-toc-text">1.2 应用程序扩缩容</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2"><span class="post-toc-text">1.3 应用程序多环境部署</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%BA%8C-%E8%AE%A1%E7%AE%97%E8%B5%84%E6%BA%90%E5%BA%94%E7%94%A8%E6%BC%94%E8%BF%9B%E8%BF%87%E7%A8%8B"><span class="post-toc-text">二、 计算资源应用演进过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E7%89%A9%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%97%9B%E7%82%B9"><span class="post-toc-text">2.1 使用物理服务器痛点</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="post-toc-text">2.2 使用虚拟机优点与缺点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BC%98%E7%A7%80%E7%82%B9"><span class="post-toc-text">2.2.1 使用虚拟机优秀点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BC%BA%E7%82%B9"><span class="post-toc-text">2.2.2 使用虚拟机缺点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="post-toc-text">2.3 使用容器的优点与缺点</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BC%98%E7%82%B9"><span class="post-toc-text">2.3.1 使用容器的优点</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="post-toc-text">2.3.2 使用容器的缺点</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E4%B8%89-what-is-a-container"><span class="post-toc-text">三、 What is a Container?</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89"><span class="post-toc-text">3.1 容器定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD"><span class="post-toc-text">3.2 容器功能</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%B9%E5%99%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="post-toc-text">3.3 容器解决了什么问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E6%AD%A5%E9%AA%A4"><span class="post-toc-text">四、使用容器步骤</span></a>
            
        
        <div class=".article-gallery"><p>用户中台的性能问题
在一个大型科技公司用户中台中，组织机构扮演着至关重要的角色，涉及到多个部门、团队和员工的关系和层级。</p>
<p>然而，随着公司规模的不断扩大和组织结构的复杂性增加，组织机构树的数据量也日益庞大。</p>
<p>这给内部用户在内部系统平台查询组织机构树时带来了一系列挑战和问题。</p>
<p>其中最突出的问题之一是查询的效率问题。</p>
<p>传统的查询方式无法有效应对组织机构树庞大数据量的挑战，导致页面在查询时出现卡顿、响应时间过长甚至超时的情况。</p>
<p>有关问题详细的数据</p>
<p>单次点击 rt时间 &gt; 70s</p>
<p>100并发 压测，平均RT时间 &gt; 160</p>
<p>在某个大型科技公司用户中台中，组织机构接口的RT时间为70s。</p>
<p>通过postman工具调用接口获取组织树，可以看到这个时间： <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img.png" alt="img.png">
我们可以看到，这一次组织树查询接口耗时大概在70s左右。
这个是太长了，性能太差了。</p>
<p>一般系统RT要求在500ms内，并且越短越好。</p>
<p>接下来，我们利用jmeter对该接口进行压测 在《
调优圣经：零基础精通Jmeter分布式压测，10Wqps+超高并发
》这篇文章中，对jmeter进行了详细介绍，</p>
<p>由于接口查询耗时太长，当前仅采用单机jmeter
进行压测，模拟100QPS的执行情况，</p>
<figure>
<a href="img_1.png" title="img_1.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_1.png" alt="img_1.png"></a>
<figcaption aria-hidden="true">img_1.png</figcaption>
</figure>
<figure>
<a href="img_2.png" title="img_2.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_2.png" alt="img_2.png"></a>
<figcaption aria-hidden="true">img_2.png</figcaption>
</figure>
<figure>
<a href="img_3.png" title="img_3.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_3.png" alt="img_3.png"></a>
<figcaption aria-hidden="true">img_3.png</figcaption>
</figure>
<figure>
<a href="img_4.png" title="img_4.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_4.png" alt="img_4.png"></a>
<figcaption aria-hidden="true">img_4.png</figcaption>
</figure>
<p>从报告中我们可以看到，100次查询请求，平均耗时接近160秒。</p>
<p>性能问题所带来的严重影响：</p>
<p>这严重影响了用户的工作效率和体验。 是严重的生产问题。</p>
<p>面对这一问题，我们需要寻找优化的解决方案，以提升组织机构树查询的性能和响应速度。</p>
<p>这涉及到在数据库层面、缓存层面以及网关层面进行针对性的优化措施。</p>
<p>通过优化数据库表结构、使用缓存技术、合理配置网关等手段，我们可以显著改善组织机构树查询的效率和用户体验。</p>
<p>接下来， 尼恩团队带大家开始，一步一步的进行优化。</p>
<h2 id="用户中台性能优化的常规思路">用户中台性能优化的常规思路</h2>
<p>首先，梳理一下用户中台性能优化的常规思路。</p>
<p>常见的优化思路如下：</p>
<ul>
<li>统一数据源：建立一个中心化的组织机构数据源，将所有部门和团队的组织机构数据集中存储，确保数据的一致性和准确性。</li>
<li>数据库优化：设计合适的数据库表结构和索引，以支持高效的组织机构查询操作。使用合适的数据库技术和优化方法，如垂直拆分或水平拆分等，来提高查询性能。</li>
<li>缓存机制：使用缓存来存储组织机构数据，如Redis等。通过合理的缓存策略，如设置适当的过期时间、使用LRU算法等，减少对数据库的频繁查询，提高查询效率。</li>
<li>分布式架构：采用分布式架构，将查询负载分散到多个节点上，通过水平扩展来提高查询性能和并发处理能力。</li>
<li>异步处理：对于复杂的组织机构查询，可以将其放入异步任务队列中处理，减少前端请求的等待时间，提高系统的并发处理能力。</li>
<li>数据同步机制：确保组织机构数据的同步和更新的及时性，使用合适的数据同步技术和机制，如定时任务、事件驱动等，保证数据的一致性。</li>
<li>前端优化：采用前端技术和界面设计优化，如数据分页加载、懒加载等方式，减少一次性加载大量组织机构数据所带来的性能压力。
本文将深入探讨针对大型科技公司中组织机构树数据量过大所引发的问题，并提供一系列优化方案。通过这些优化措施，我们将帮助您克服组织机构树查询中的困难，使您能够更快速、高效地获取所需的组织机构信息，提升工作效率和决策能力。</li>
</ul>
<p>接下来，本文将带着大家一起实践组织架构树的优化!</p>
<h3 id="第一轮优化数据库层面优化提升60倍">第一轮优化：数据库层面优化，提升60倍</h3>
<p>数据库优化是解决大型科技公司组织机构查询问题的重要一环。下面是一些详细的数据库优化策略和技术：</p>
<ul>
<li>合适的表结构设计：
根据组织机构的特点，设计合适的表结构，以支持高效的查询操作。可以采用适当的关系型数据库或者NoSQL数据库，根据具体需求选择合适的数据库引擎。
使用范式化或者反范式化的设计方式，根据查询需求和数据一致性的要求来决定表结构的规范化程度。
使用合适的数据类型来存储组织机构数据，以节省存储空间并提高查询效率。</li>
<li>索引优化：
通过创建合适的索引来加速组织机构查询。根据查询的字段和条件，为经常被用于查询的列创建索引，以提高查询的速度。
选择适当的索引类型，如B-tree索引、哈希索引或者全文索引，根据具体查询的需求和数据的特点做出选择。
定期进行索引维护和优化，包括索引重建、碎片整理等操作，以保持索引的性能。</li>
<li>查询优化：
编写高效的查询语句，使用合适的SQL语法和操作符，避免不必要的查询或子查询，提高查询的效率。
使用合适的查询缓存机制，如数据库自带的查询缓存或者第三方缓存工具，以减少对数据库的频繁查询。
避免过度使用JOIN操作，尽量减少关联查询的复杂性。考虑使用预加载或延迟加载的方式，根据实际需求来优化查询操作。
分析查询执行计划，通过索引优化、表结构调整或者SQL重写等手段，改善查询执行计划的性能。</li>
<li>数据分区和分片：
如果组织机构数据量非常大，可以考虑将数据分区或者分片存储。通过按照一定规则将数据拆分为多个分区或者分片，提高查询的并行度和扩展性。
使用分区表或者分片表的方式，将数据均匀地分布到多个物理存储设备或者数据库实例中，提高查询的性能和响应时间。</li>
<li>定期数据清理和维护：
定期清理不再使用的数据，如过期的组织机构信息或者历史数据。通过删除或者归档这些数据，可以减少数据库的存储压力和提高查询性能。
定期进行数据库的维护工作，包括备份、日志清理、统计信息更新等操作，以保持数据库的健康状态和性能。
一般组织机构对应的表结构如下所示： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `department` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `parent_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `remark` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `created_at` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `deleted` tinyint(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `department_parent_id_IDX` (`parent_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci COMMENT<span class="operator">=</span><span class="string">&#x27;部门&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
在这个表结构中，每个目录节点都有一个唯一的id标识和一个name字段表示部门的名称。</li>
</ul>
<p>parent_id字段表示该节点的父节点的id。根节点可以通过parent_id为0来表示。</p>
<p>注意添加parent_id为索引，加快查询效率。</p>
<p>通过这种表结构，可以使用递归查询或者多级查询来构建整个树的结构。</p>
<p>例如，通过以下查询可以获取第一层目录树： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> department <span class="keyword">WHERE</span> parent_id <span class="operator">=</span> <span class="string">&#x27;0L&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
然后，通过递归或者多级查询，可以根据每个节点的id值，获取其子节点。</p>
<p>我们预先生产了一万多条的测试数据，组织结构层级最大4级，</p>
<p><a href="img_5.png" title="img_5.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_5.png" alt="img_5.png"></a>
获取组织机构树的示例代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DepartmentDTO <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DepartmentDTO</span> <span class="variable">departmentDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentDTO</span>();</span><br><span class="line">    departmentDTO.setId(<span class="number">0L</span>);</span><br><span class="line">    queryChildren(departmentDTO);</span><br><span class="line">    <span class="keyword">return</span> departmentDTO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归查询</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">queryChildren</span><span class="params">(DepartmentDTO parent)</span> &#123;</span><br><span class="line">    List&lt;DepartmentPO&gt; children = departmentDao.queryByParentId(parent.getId());</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(children)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DepartmentPO po : children) &#123;</span><br><span class="line">        <span class="type">DepartmentDTO</span> <span class="variable">departmentDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentDTO</span>();</span><br><span class="line">        BeanUtil.copyProperties(po, departmentDTO);</span><br><span class="line">        parent.getChildren().add(departmentDTO);</span><br><span class="line">        queryChildren(departmentDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
回到优化之前，接下来调用接口获取组织树： <a href="img_6.png" title="img_6.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_6.png" alt="img_6.png"></a> 优化之后，进行单次接口的 调用接口，数据如下： <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_7.png" alt="img_7.png">
可以发现，通过降低SQL调用次数，接口耗时从70多s降低到了800ms左右。</p>
<p>接下来，我们同样对接口进行下压测，</p>
<p>压测后，聚合报告如下所示： <a href="img_8.png" title="img_8.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_8.png" alt="img_8.png"></a>
聚合报告显示，100次查询请求平均耗时仅2秒多，且吞吐量提升近60倍。</p>
<p>当然我们还需要进一步优化，以减少接口耗时和提升吞吐量。</p>
<h2 id="第二步应用层优化提升70倍">第二步：应用层优化，提升70倍</h2>
<p>在第一步优化过程中，我们采用级联查询，从根节点查询下级子节点列表，再从下级子节点查询下下级节点，每次查询都要提交SQL到MySQL，相当于一次接口调用，后端需要发起上万次SQL请求，效率非常低下。</p>
<p>因此我们可以在应用服务里，每次查询一次性从数据库中获取所有数据，在内存里排序、拼装成树形数据，</p>
<p>代码示例如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">queryChildren2</span><span class="params">(DepartmentDTO root)</span> &#123;</span><br><span class="line">    <span class="comment">// 一次性取出所有数据</span></span><br><span class="line">    List&lt;DepartmentPO&gt; list = departmentDao.findAll(Sort.by(<span class="string">&quot;parentId&quot;</span>, <span class="string">&quot;id&quot;</span>).ascending());</span><br><span class="line">    Map&lt;Long, DepartmentDTO&gt; departmentMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    departmentMap.put(root.getId(), root);</span><br><span class="line">    <span class="comment">// 遍历数据，组成树形结构</span></span><br><span class="line">    <span class="keyword">for</span>(DepartmentPO po : list) &#123;</span><br><span class="line">        <span class="type">DepartmentDTO</span> <span class="variable">departmentDTO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentDTO</span>();</span><br><span class="line">        BeanUtil.copyProperties(po, departmentDTO);</span><br><span class="line">        departmentMap.put(po.getId(), departmentDTO);</span><br><span class="line">        <span class="type">DepartmentDTO</span> <span class="variable">parent</span> <span class="operator">=</span> departmentMap.get(po.getParentId());</span><br><span class="line">        parent.getChildren().add(departmentDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 调用接口, 结果如下： <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_9.png" alt="img_9.png">
可以看到，应用层优化后，接口的耗时从700多ms降低到100ms左右，基本已满足生产环境要求的接口耗时，接下来，我们还需要对接口进行压测
## 第三步：分布式缓存优化，但是高并发场景失败率过高
传统的数据库查询往往需要耗费大量的时间和资源，特别是在数据量庞大的情况下。</p>
<p>通过引入分布式缓存，我们可以将组织机构数据缓存在内存中，以避免频繁访问数据库的开销。</p>
<p>分布式缓存采用分布式架构，将数据存储在多个缓存节点中，每个节点都具备独立的内存和处理能力。</p>
<p>当进行组织机构查询时，首先检查缓存中是否存在相应的数据。</p>
<p>如果缓存中存在数据，则直接返回结果，避免了对数据库的查询操作。这样可以大大减少查询的响应时间，提高整体系统的性能。</p>
<p>在引入分布式缓存时，需要设计合理的缓存策略和数据更新机制。</p>
<p>可以采用缓存失效策略，设置合适的缓存过期时间，确保缓存中的数据与数据库的数据保持一致。当组织机构数据发生变化时，及时更新缓存，保证查询结果的准确性。</p>
<p>此外，还可以考虑使用分布式缓存技术如Redis或Memcached，并进行合理的缓存数据划分和数据分片，以实现横向扩展和负载均衡。这样可以提高系统的可伸缩性和容错性，应对高并发访问和大规模组织机构数据的查询需求。</p>
<p>总之，引入分布式缓存是一种高效的优化策略，通过减少对数据库的访问次数和加速查询响应，可以极大地提升组织机构查询的效率和响应时间，从而提高整体系统的性能和用户体验。</p>
<p>首先，我们尝试在接口调用时，使用redis缓存组织结构树，之后每次接口请求时，都优先查询缓存，</p>
<p>代码示例如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DepartmentDTO <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查询缓存</span></span><br><span class="line">    <span class="type">DepartmentDTO</span> <span class="variable">departmentDTO</span> <span class="operator">=</span> (DepartmentDTO) redisTemplate.opsForValue().get(DEPARTMENT_CACHE_KEY);</span><br><span class="line">    <span class="comment">// 缓存不存在则查询数据库</span></span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(departmentDTO)) &#123;</span><br><span class="line">        departmentDTO = <span class="keyword">new</span> <span class="title class_">DepartmentDTO</span>();</span><br><span class="line">        departmentDTO.setId(<span class="number">0L</span>);</span><br><span class="line">        queryChildren2(departmentDTO);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新缓存</span></span><br><span class="line">    redisTemplate.opsForValue().set(DEPARTMENT_CACHE_KEY, departmentDTO, <span class="number">1</span>, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> departmentDTO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 使用分布式 jmeter集群的方式来进行压测
为了模拟高并发场景，使用分布式 jmeter集群的方式来进行压测。</p>
<p>由于单台jmeter压测受限于本地机器的CPU，内存，网络及其他原因，需要采用jmeter集群的方式来进行压测。</p>
<p>这里我们将参考《
调优圣经：零基础精通Jmeter分布式压测，10Wqps+超高并发
》这篇文章，利用Jmeter集群来进行压测，</p>
<p>Jemter集群采用docker-compose的方式搭建，</p>
<p>在本机新建jmeter文件夹，在文件夹下创建jmeter-master文件夹， <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_10.png" alt="img_10.png"></p>
<p>docker-compose.yml内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jmeter-master:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zhangyx1619/jmeter-master:orcaljdk17-jmeter5.5-graphs-plugins-release</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;./jmeter-master:/usr/local/jmeter/apache-jmeter-5.5/work_space/&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">swarmnet</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jmeter-master</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">com.service.name=jmeter-master</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">1s</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">rollback</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">jmeter-slave01:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zhangyx1619/jmeter-slave:orcaljdk17-jmeter5.5-graphs-plugins-release</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jmeter-slave01:/usr/local/jmeter/apache-jmeter-5.5/</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">swarmnet</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jmeter-slave01</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">com.service.name=jmeter-slave01</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">1s</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">rollback</span></span><br><span class="line">  <span class="attr">jmeter-slave02:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zhangyx1619/jmeter-slave:orcaljdk17-jmeter5.5-graphs-plugins-release</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jmeter-slave02:/usr/local/jmeter/apache-jmeter-5.5/</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">swarmnet</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jmeter-slave02</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">com.service.name=jmeter-slave02</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">1s</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">rollback</span></span><br><span class="line">  <span class="attr">jmeter-slave03:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">zhangyx1619/jmeter-slave:orcaljdk17-jmeter5.5-graphs-plugins-release</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">jmeter-slave03:/usr/local/jmeter/apache-jmeter-5.5/</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">swarmnet</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jmeter-slave03</span></span><br><span class="line">    <span class="attr">deploy:</span></span><br><span class="line">      <span class="attr">mode:</span> <span class="string">global</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">com.service.name=jmeter-slave03</span></span><br><span class="line">      <span class="attr">update_config:</span></span><br><span class="line">        <span class="attr">parallelism:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">1s</span></span><br><span class="line">        <span class="attr">failure_action:</span> <span class="string">rollback</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">swarmnet:</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">bridge</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">jmeter-slave01:</span></span><br><span class="line">  <span class="attr">jmeter-slave02:</span></span><br><span class="line">  <span class="attr">jmeter-slave03:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在当前jemeter目录打开终端，运行docker命令, 启动容器。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>
启动后，容器详情如下： <a href="img_11.png" title="img_11.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_11.png" alt="img_11.png"></a>
其中包含一个主节点和4个子节点。</p>
<p>接下来，修改jmx脚本， 线程组的线程数我们调大到1000，
这样的话，4个子节点分别发起1000次请求，相当于是模拟4000 QPS 压测， <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_12.png" alt="img_12.png"></p>
<p>点击左上角文件 -&gt; 保存 , 将当前jmeter脚本department.jmx
文件，保存到jmeter-master文件夹下， <a href="img_13.png" title="img_13.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_13.png" alt="img_13.png"></a>
ok，到这里一切准备就绪后，就可以开始执行压测命令，</p>
<p>在终端运行如下命令： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it jemeter-jmeter-master-1 jmeter  -n -t /usr/local/jmeter/apache-jmeter-5.5/work_space/department.jmx -r -l /usr/local/jmeter/apache-jmeter-5.5/work_space/department.jtl -e -o /usr/local/jmeter/apache-jmeter-5.5/work_space/html/ </span><br><span class="line"></span><br></pre></td></tr></table></figure>
这是一个使用Docker执行JMeter性能测试的命令，具体含义如下： - docker
exec: 运行一个命令在Docker容器中执行操作。 - -it:
分配一个交互式终端，并将其连接到容器的输入和输出，以便与JMeter进行交互。
- jemeter-jmeter-master-1:
Docker容器的名称或ID，指定要执行命令的目标容器，这里是主节点容器名称。 -
jmeter: 要执行的命令，这里是执行JMeter性能测试。 - -n:
在非GUI模式下运行JMeter。 - -t
/usr/local/jmeter/apache-jmeter-5.5/work_space/department.jmx:
指定要运行的JMX测试计划文件的路径和文件名。 - -r:
运行以分布式方式执行测试。 - -l
/usr/local/jmeter/apache-jmeter-5.5/work_space/department.jtl:
指定测试结果的日志文件路径和文件名。 - -e: 生成HTML格式的测试报告。 - -o
/usr/local/jmeter/apache-jmeter-5.5/work_space/html/:
指定生成的HTML测试报告的输出目录路径。
通过这个命令，您可以在指定的Docker容器中执行JMeter性能测试，并生成相应的测试结果日志和HTML报告。请注意，命令中的文件路径和名称需要根据实际情况进行修改。</p>
<p>执行过程如下图所示：</p>
<p><a href="img_14.png" title="img_14.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_14.png" alt="img_14.png"></a> 查看生成的报告 <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_16.png" alt="img_16.png">
我们可以看到，4台jmeter节点模拟1000个并发，一共是4000并发，Fail的占比90%多，</p>
<p>服务器会出现大量的异常， <a href="img_17.png" title="img_17.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_17.png" alt="img_17.png"></a>
根因分析：</p>
<p>异常的原因是redis读取超时，因为一个键值对的数据量比较大，导致redis出现了BigKey问题，我们需要进一步优化</p>
<p>狼来了： BigKey问题来了</p>
<h2 id="第四步bigkey问题优化4000并发场景到100ms">第四步：BigKey问题优化，4000并发场景到100ms</h2>
<p>在Redis中，BigKey指的是占用大量内存空间的键值对。当一个键值对的数据量过大，超过Redis的配置限制或者内存容量时，就称之为BigKey。</p>
<p>BigKey会导致以下问题：</p>
<p>内存占用过高：BigKey占用大量内存空间，可能导致Redis服务器的内存资源紧张，影响其他操作和缓存数据的存储。
延迟和性能下降：由于读写大型BigKey的数据需要较长的时间，会导致读写操作的延迟增加，并且消耗更多的CPU资源和网络带宽，影响系统的整体性能。
Redis持久化和备份问题：BigKey在进行持久化（如RDB快照或AOF日志）或备份时，会增加持久化和备份的时间和资源消耗。
解决BigKey问题的一些优化方法包括：</p>
<ul>
<li>数据拆分：将大型BigKey拆分成多个较小的键值对，根据数据的逻辑关联性和查询模式进行合理的拆分和分组。这样可以降低单个键值对的大小，减少内存占用。</li>
<li>分片存储：将数据分散存储在多个键中，使用合适的哈希函数或者分片算法，将数据均匀地分散到不同的键中，避免单个键值对过大。这样可以平衡数据的存储和访问压力。</li>
<li>数据压缩：对于可以压缩的数据类型（如字符串或JSON格式的数据），可以使用压缩算法（如LZF、Snappy、Gzip等）进行压缩，减少BigKey的内存占用。</li>
<li>数据分页和增量加载：对于查询结果过大的BigKey，可以采用数据分页或者增量加载的方式，只加载部分数据或者按需加载，以降低单次查询的数据量和内存消耗。</li>
<li>避免无意义的数据存储：避免将无需持久化或频繁变更的数据存储为BigKey，可以使用临时缓存或者其他数据存储方案。
通过合理的数据拆分、分片存储和压缩等优化方法，可以有效地解决BigKey问题，提高Redis的性能和资源利用率。</li>
</ul>
<p>因为在根节点下的第一级优10个组织，这10个组织分别有不同的子孙节点，我们可以尝试将单个key先拆分成10个key，每个key分别对应这10个组织及子节点数据。</p>
<p>示例代码如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DepartmentDTO <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DepartmentDTO</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DepartmentDTO</span>();</span><br><span class="line">    root.setId(<span class="number">0L</span>);</span><br><span class="line">    <span class="comment">// 从10个key里获取缓存数据，放入到根节点的children集合里</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="type">DepartmentDTO</span> <span class="variable">child</span> <span class="operator">=</span> (DepartmentDTO)  redisTemplate.opsForValue().get(DEPARTMENT_CACHE_KEY + i);</span><br><span class="line">        <span class="comment">// 没有缓存数据</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(child)) &#123;</span><br><span class="line">            root.setChildren(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        root.getChildren().add(child);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root.getChildren().size() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// 查询数据库</span></span><br><span class="line">       queryChildren2(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据按照1级部门存储到10个key</span></span><br><span class="line">    List&lt;DepartmentDTO&gt; children = root.getChildren();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(DEPARTMENT_CACHE_KEY + i, children.get(i), <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 接下来，继续进行分布式压测： <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_18.png" alt="img_18.png"> 我们再来看下生成的报告： <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_19.png" alt="img_19.png">
这时我们可以看到通过率从8%提升到70%多，如果我们将key的数量提升到100,
通过率将进一步提升。</p>
<p>有兴趣的同学可以来尝试继续优化直到通过率为100%。</p>
<h2 id="第五步本地缓存优化优化到20ms">第五步：本地缓存优化，优化到20ms</h2>
<p>在分布式缓存的基础上，引入本地缓存是进一步提升组织机构查询效率和响应时间的一种优化方案。</p>
<p>本地缓存是指将数据缓存在应用程序的内存中，以避免频繁地访问分布式缓存或数据库，从而快速响应查询请求。</p>
<p>引入本地缓存的好处是可以减少对分布式缓存的访问次数，从而降低网络延迟和通信开销。</p>
<p>当应用程序发起组织机构查询时，首先检查本地缓存中是否存在相应的数据。如果数据在本地缓存中命中，则无需进一步访问分布式缓存或数据库，可以直接返回结果，极大地提升了查询的效率和响应时间。</p>
<p>本地缓存的使用需要考虑以下几个关键因素：</p>
<ul>
<li>缓存策略：选择合适的缓存策略，如LRU（最近最少使用）、LFU（最近最不常用）等，以平衡内存使用和数据命中率。</li>
<li>缓存更新机制：在组织机构数据发生变化时，及时更新本地缓存。可以通过订阅数据库或分布式缓存的数据变更事件，保持本地缓存与数据源的一致性。</li>
<li>缓存失效处理：设置合理的缓存失效时间，以确保缓存中的数据不过期。可以根据数据更新的频率和重要性进行调整。</li>
<li>内存管理：合理管理本地缓存使用的内存，避免因缓存过多导致内存溢出或应用程序性能下降的问题。
引入本地缓存的优化方案需要综合考虑应用程序的特点、数据的更新频率和一致性要求。合理使用本地缓存可以减少对分布式缓存和数据库的访问，提升组织机构查询的效率和响应时间，从而提高系统的整体性能和用户体验。</li>
</ul>
<p>在当前SpringBoot框架下，可以通过以下步骤集成Caffeine作为本地缓存：</p>
<ul>
<li><p>1.添加Caffeine依赖：在pom.xml文件中添加Caffeine的依赖项:
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>2.创建缓存配置类：创建一个Java类，用于配置Caffeine缓存
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cache.CacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cache.caffeine.CaffeineCacheManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> com.github.benmanes.caffeine.cache.Caffeine;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Caffeine&lt;Object, Object&gt; <span class="title function_">caffeineConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">10</span>, TimeUnit.MINUTES) <span class="comment">// 设置缓存失效时间为10分钟</span></span><br><span class="line">                .maximumSize(<span class="number">10_000</span>) <span class="comment">// 设置缓存的最大容量为10_000</span></span><br><span class="line">                .recordStats(); <span class="comment">// 启用统计信息，可通过Cache.stats()获取缓存命中率等统计数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">cacheManager</span><span class="params">(Caffeine&lt;Object, Object&gt; caffeine)</span> &#123;</span><br><span class="line">        <span class="type">CaffeineCacheManager</span> <span class="variable">cacheManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CaffeineCacheManager</span>();</span><br><span class="line">        cacheManager.setCaffeine(caffeine);</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在上面的示例中，我们配置了一个名为"cacheManager"的缓存管理器，使用了Caffeine作为底层的缓存实现，并设置了缓存的失效时间和最大容量。</p></li>
<li><p>3.使用缓存：在需要缓存的方法上添加@Cacheable注解，以告诉Spring应该缓存该方法的返回值。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cacheable(&quot;department-cache&quot;)</span></span><br><span class="line"><span class="keyword">public</span> DepartmentDTO <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
在上述示例中，findAll方法会首先检查名为"department-cache"的缓存中是否存在对应的数据。如果存在，直接从缓存中返回数据；如果缓存中不存在，则执行方法体的逻辑，并将返回值缓存起来供下次使用。</p></li>
</ul>
<p>同样我们调用下接口，看下执行时间 <a href="img_20.png" title="img_20.png" class="gallery-item" style="box-shadow: none;"> <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_20.png" alt="img_20.png"></a> 由于采用本地缓存，耗时几乎忽略不计。</p>
<p>接下来，继续执行下jmeter集群压测，压测报告如下所示： <img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//img_21.png" alt="img_21.png"></p>
<p>优化总结 如果本地缓存命中， 经过这一轮优化， 性能提升到
20ms，提升700倍</p>
<p>如果本地缓存位命中， 经过上一轮优化， 性能提升到 100ms
，提升3500倍</p>
<h2 id="第六步网关层面的优化">第六步：网关层面的优化</h2>
<p>除了数据库、缓存、bigkey打散、本地缓存优化之外，还有很多其他的优化：</p>
<ul>
<li>网关层面的优化</li>
<li>系统层面的优化等等。 接下来说一下网关层面的优化。</li>
</ul>
<p>在网关层面进行优化可以提高组织机构树接口查询的性能和可扩展性。</p>
<p>以下是一些优化方案： 1、Nginx压缩：</p>
<p>在Nginx配置中启用压缩功能，将响应数据进行压缩，减少数据传输的大小，提高网络传输效率和响应速度。
配置gzip指令开启压缩，可以设置合适的压缩级别和压缩类型。 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_types text/plain text/css application/json;</span><br><span class="line">    gzip_comp_level 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
2、网关缓存：
在Nginx中，可以通过配置代理缓存来缓存接口的响应结果。以下是详细的步骤：</p>
<h2 id="一.启用代理缓存">一.启用代理缓存：</h2>
<p>在Nginx的配置文件中，开启代理缓存功能并定义一个缓存区域。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=60m use_temp_path=off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - /path/to/cache：指定缓存存储路径。 -
levels=1:2：定义缓存路径层级。 -
keys_zone=my_cache:10m：为缓存区域指定一个名称（my_cache）和分配的内存大小（10MB）。
- max_size=10g：设置缓存区域的最大容量为10GB。 -
inactive=60m：指定缓存项在60分钟内没有被访问时被认为是过期的。 -
use_temp_path=off：禁止使用临时路径。</p>
<p>二.配置代理缓存： 在Nginx的配置文件中，为需要缓存的接口添加缓存配置。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  server &#123;</span><br><span class="line">    location /api/department &#123;</span><br><span class="line">        proxy_cache my_cache;</span><br><span class="line">        proxy_cache_valid 200 1d;</span><br><span class="line">        proxy_pass http://backend_server;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> - proxy_cache
my_cache：指定使用前面定义的缓存区域（my_cache）进行缓存。 -
proxy_cache_valid 200
1d：设置缓存有效期为1天，对于状态码为200的响应进行缓存。 - proxy_pass
http://backend_server：指定反向代理的目标后端服务器。 三，清除缓存：
如果需要手动清除缓存，可以使用Nginx的proxy_cache_purge模块，通过发送特定请求来清除缓存。
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /purge-cache &#123;</span><br><span class="line">    proxy_cache_purge my_cache &quot;$scheme$request_method$host$request_uri&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - proxy_cache_purge：启用proxy_cache_purge模块。 -
my_cache：指定要清除的缓存区域。 - "<span class="math inline">\(scheme\)</span>request_method<span class="math inline">\(host\)</span>request_uri"：指定要清除的缓存键值。</p>
<p>通过上述配置，Nginx会在接收到请求时先查看缓存，如果缓存中存在对应的响应，则直接返回缓存的结果，减少对后端服务的请求。如果缓存中不存在或已过期，则会转发请求到后端服务，并将响应结果缓存起来，以供后续相同请求使用。</p>
<p>请注意，缓存接口需要根据具体的业务需求和接口特性进行配置。需要根据接口的频率、数据更新频率和缓存策略进行合理的调整。</p>
<p>对于动态生成的树形数据页面，也可以采用页面缓存技术，将页面内容缓存到CDN或其他缓存中，并设置合适的缓存过期时间。</p>
<h2 id="从70s到20ms调优小结">从70s到20ms调优小结</h2>
<p>针对组织结构树的优化设计，我们可以在数据库层面、缓存层面和NGINX网关层面进行优化，以提高查询性能和系统的可伸缩性。</p>
<p>在数据库层面，我们可以采取以下优化设计：</p>
<p>使用适当的表结构和索引，优化组织结构树的存储和查询效率。
考虑采用合适的分库分表策略，将数据水平拆分，减少单表数据量。
针对组织结构树的查询，使用适当的查询语句和优化技巧，如递归查询、嵌套集模型等。
在缓存层面，我们可以采取以下优化设计：</p>
<p>使用Redis等缓存技术，将组织结构树的数据缓存在内存中，减少对数据库的访问次数。
针对频繁访问的组织结构树数据，设置合适的缓存过期时间和缓存策略。
使用合理的缓存命名规则和缓存键设计，确保缓存的准确性和一致性。
在NGINX网关层面，我们可以采取以下优化设计：</p>
<p>使用Nginx的压缩功能，减小响应数据的大小，提高网络传输效率。
使用CDN缓存静态资源，减轻网关和后端服务器的负载，加速资源传输。
配置代理缓存，将组织结构树接口的响应结果缓存起来，减少对后端服务的请求。
设置适当的负载均衡机制，分发请求到多个后端服务实例，提高系统的可扩展性和容错性。
综合上述优化设计，可以大大提升组织结构树接口的查询性能和系统的可伸缩性。通过数据库的优化，可以提高数据的存储和查询效率；通过缓存的优化，可以减少对数据库的访问次数；通过网关层面的优化，可以降低网络传输成本和后端服务的负载压力。这些综合的优化措施将显著改善系统的整体性能和用户体验。</p>
<p>=============================================================</p>
<h1 id="应用application部署容器化演进之路">应用（Application）部署容器化演进之路</h1>
<h1 id="一应用程序部署痛点">一、应用程序部署痛点</h1>
<h2 id="应用程序部署流程">1.1 应用程序部署流程</h2>
<p><strong>举例：部署一个JAVA编程语言开发的Web应用，以War包放入Tomcat方式部署。</strong></p>
<ul>
<li>部署过程如下：
<ul>
<li>服务器配置运行环境:JAVA代码运行环境，例如JDK或JRE</li>
<li>服务器上安装Tomcat web中间件，用于运行War包</li>
<li>把JAVA Web对应的War包放置于Tomcat对应目录</li>
<li>在服务器上启动Tomcat应用</li>
<li>可选：涉及数据库（MySQL）或缓存系统(Redis)等都需要逐一部署。</li>
</ul></li>
</ul>
<h2 id="应用程序扩缩容">1.2 应用程序扩缩容</h2>
<ul>
<li>涉及多台服务器部署相同的上述环境</li>
<li>痛点：上述环境部署要重新实施一遍，较浪费人力与物力成本</li>
</ul>
<h2 id="应用程序多环境部署">1.3 应用程序多环境部署</h2>
<ul>
<li>环境：本地测试环境、预发布环境、生产环境</li>
<li>在本地测试环境运行没有问题，但在预发布环境中出现了问题，甚至上面2种环境都没有问题，到了生产环境就有问题了。</li>
<li>需求：一次成功，可到处运行。</li>
</ul>
<h1 id="二-计算资源应用演进过程">二、 计算资源应用演进过程</h1>
<h2 id="使用物理服务器痛点">2.1 使用物理服务器痛点</h2>
<p><img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//image-20220118161531257.png"></p>
<ul>
<li><p>从物理服务器自身管理角度</p>
<ul>
<li>物理服务器环境部署人力成本大，特别是在自动化手段不足的情况下，依靠人肉运维的方式解决。</li>
<li>当物理服务器出现宕机后，服务器重启时间过长，短则1-2分钟，长则3-5分钟，有背于服务器在线时长达到99.999999999%标准的要求</li>
<li>物理服务器在应用程序运行期间硬件出现故障，解决较麻烦</li>
<li>物理服务器计算资源不能有效调度使用，无法发挥其充足资源的优势</li>
</ul></li>
<li><p>从物理服务器部署应用程序角度</p>
<ul>
<li>物理服务器环境部署浪费时间，没有自动化运维手段，时间是成倍增加的</li>
<li>在物理服务器上进行应用程序配置变更，需要重新实施前述步骤</li>
</ul></li>
</ul>
<h2 id="使用虚拟机优点与缺点">2.2 使用虚拟机优点与缺点</h2>
<figure>
<img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//image-20220118161210084.png" alt="image-20220118161210084">
<figcaption aria-hidden="true">image-20220118161210084</figcaption>
</figure>
<h3 id="使用虚拟机优秀点">2.2.1 使用虚拟机优秀点</h3>
<ul>
<li><p>从虚拟机本身管理角度</p>
<ul>
<li>虚拟机较物理服务器轻量，可借助虚拟机模板实现虚拟机快捷生成及应用</li>
<li>虚拟机中部署应用与物理服务器一样可控性强，且当虚拟机出现故障时，可直接使用新的虚拟机代替</li>
<li>在物理服务器中使用虚拟机可高效使用物理服务器的资源</li>
<li>虚拟机与物理服务器一样可达到良好的应用程序运行环境的隔离</li>
</ul></li>
<li><p>从在虚拟机中部署应用程序角度</p>
<ul>
<li>在虚拟机中部署应用，容易扩容及缩容实现</li>
<li>与物理服务器相比较，当部署应用程序的虚拟机出现宕机时，可以快速启动，时间通常可达秒级，10秒或20秒即可启动，应用程序可以继续提供服务</li>
<li>应用程序迁移方便</li>
</ul></li>
</ul>
<h3 id="使用虚拟机缺点">2.2.2 使用虚拟机缺点</h3>
<ul>
<li>虚拟机管理软件本身占用物理服务器计算资源较多，例如:VMware
Workstation
Pro就会占用物理服务器大量资源，所以一般在企业应用中使用KVM虚拟机较多。</li>
<li>虚拟机底层硬件消耗物理服务器资源较大，例如：虚拟机操作系统硬盘，会直接占用大量物理服务器硬盘空间</li>
<li>相较于容器技术，虚拟机启动时间过长，容器启动可按毫秒级计算</li>
<li>虚拟机对物理服务器硬件资源调用添加了调链条，存在浪费时间的现象，所以虚拟机性能弱于物理服务器</li>
<li>由于应用程序是直接部署在虚拟机硬盘上，应用程序迁移时，需要连同虚拟机硬盘中的操作系统一同迁移，会导致迁移文件过大，浪费更多的存储空间及时间消耗过长</li>
</ul>
<h2 id="使用容器的优点与缺点">2.3 使用容器的优点与缺点</h2>
<figure>
<img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//image-20220118161301903.png" alt="image-20220118161301903">
<figcaption aria-hidden="true">image-20220118161301903</figcaption>
</figure>
<h3 id="使用容器的优点">2.3.1 使用容器的优点</h3>
<ul>
<li>不需要为容器安装操作系统，可以节约大量时间</li>
<li>不需要通过手动的方式在容器中部署应用程序的运行环境，直接部署应用就可以了</li>
<li>不需要管理容器网络，以自动调用的方式访问容器中应用提供的服务</li>
<li>方便分享与构建应用容器，一次构建，到处运行</li>
<li>毫秒级启动</li>
<li>容器可直接使用物理服务器硬件资源，物理服务器硬件资源利用率高，性能较好。</li>
</ul>
<h3 id="使用容器的缺点">2.3.2 使用容器的缺点</h3>
<p>对于对使用物理服务器、虚拟机已成为习惯的小伙伴来说，容器化可控性不强，最直观的就是对容器管理访问，总想按物理服务器或虚拟机的方式去管理它，其实容器与物理服务器、虚拟机管理方式上有着本质的区别的，最好不要管理。</p>
<h1 id="三-what-is-a-container">三、 What is a Container?</h1>
<h2 id="容器定义">3.1 容器定义</h2>
<figure>
<img src="/2023/06/04/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96%E8%B0%83%E4%BC%98/%E6%8E%A5%E5%8F%A3%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98//image-20220118161407959.png" alt="image-20220118161407959">
<figcaption aria-hidden="true">image-20220118161407959</figcaption>
</figure>
<ul>
<li><p>虚拟机</p>
<ul>
<li>采用虚拟化技术手段实现物理服务器计算资源打包的方式，为应用程序提供类物理服务器运行环境</li>
<li>能够实现应用程序与应用程序之间的隔离</li>
<li>使用自动化技术部署应用程序及应用程序迁移较方便</li>
<li>可横向扩展</li>
</ul></li>
<li><p>容器</p>
<ul>
<li>容器是轻量级物理服务器计算资源的打包方式，即轻量级虚拟机，为应用程序提供类虚拟机运行环境。</li>
<li>可在物理服务器中实现高密度部署</li>
</ul></li>
<li><p>容器与虚拟机对比</p></li>
</ul>
<table>
<thead>
<tr>
<th>对比属性</th>
<th>容器（Container）</th>
<th>虚拟机（VM）</th>
</tr>
</thead>
<tbody>
<tr>
<td>隔离性</td>
<td>基于进程隔离</td>
<td>提供资源的完全隔离</td>
</tr>
<tr>
<td>启动时间</td>
<td>毫秒级或秒级</td>
<td>秒级或分钟级</td>
</tr>
<tr>
<td>内核</td>
<td>共用宿主机内核</td>
<td>使用独立内核</td>
</tr>
<tr>
<td>占用资源</td>
<td>MB级</td>
<td>GB级</td>
</tr>
<tr>
<td>系统支持容量（同级别）</td>
<td>支持上千个容器</td>
<td>几十台虚拟机</td>
</tr>
</tbody>
</table>
<h2 id="容器功能">3.2 容器功能</h2>
<ul>
<li><p>安装容器管理工具，例如Docker,Containerd等，把应用以容器化的方式运行</p></li>
<li><p>应用在自己的容器中运行，实现应用程序间隔离</p></li>
<li><p>应用程序运行的容器可以生成应用程序模板文件，即容器镜像（Image），其不可变，即为云原生代表技术基础设施不可变,且可以在其它的物理服务器中运行。</p></li>
</ul>
<h2 id="容器解决了什么问题">3.3 容器解决了什么问题</h2>
<ul>
<li>快速交付和部署应用 (镜像与容器)</li>
<li>资源的高效利用和隔离 (在物理机上实现高密度部署)</li>
<li>便捷迁移和扩缩容(一次构建，多处运行)</li>
</ul>
<h1 id="四使用容器步骤">四、使用容器步骤</h1>
<ul>
<li><p>安装容器管理工具</p>
<ul>
<li>Docker (Docker公司)</li>
<li>Containerd (2017年docker捐给CNCF云原生计算基金会)</li>
<li>Pouch (阿里云)</li>
</ul></li>
<li><p>搜索/下载容器镜像(Image)</p></li>
<li><p>使用容器镜像生成容器(容器镜像中的应用程序启动)</p></li>
<li><p>终端用户(互联网用户或其它应用程序)访问</p></li>
<li><p>迁移部署(可直接把正在运行的容器打包成新的容器镜像，在其它主机上运行即可。)</p></li>
</ul>
</div>
    </div>

    <div class="post-meta">
        <i>
        
            <span>2023-06-04</span>
            
                <span>该篇文章被 albert dong</span>
            
            
             
                <span>归为分类:
                    
                    
                        <a href='../../../../../categories/%E7%B3%BB%E7%BB%9F%E8%B0%83%E4%BC%98/'>
                            系统调优
                        </a>
                    
                </span>
            
        
        </i>
    </div>
    <br>
    
    
        
            
    
            <div class="post-footer-pre-next">
                
                    <span>上一篇：<a href='../../../17/%E6%B6%88%E6%81%AF/kafka/'>kafka</a></span>
                

                
                    <span class="post-footer-pre-next-last-span-right">下一篇：<a href="../../%E8%BF%90%E7%BB%B4/%E5%AE%B9%E5%99%A8/%E5%BA%94%E7%94%A8%EF%BC%88APP%EF%BC%89%E9%83%A8%E7%BD%B2%E5%AE%B9%E5%99%A8%E5%8C%96%E6%BC%94%E8%BF%9B%E4%B9%8B%E8%B7%AF/">容器的演进发展</a>
                    </span>
                
            </div>
    
        
    

    
        

     
</div>



                                      
                    
                    
                    <div class="footer">
    
        <span> 
            © 1949-2024 China 

            
                

            
        </span>
       
    
</div>



<!--这是指一条线往下的内容-->
<div class="footer-last">
    
            <span>🌊看过大海的人不会忘记海的广阔🌊</span>
            
                <span class="footer-last-span-right"><i>本站由<a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/index.html">Hexo</a>驱动｜使用<a target="_blank" rel="noopener" href="https://github.com/HiNinoJay/hexo-theme-A4">Hexo-theme-A4</a>主题</i></span>
            
    
</div>


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>

    <!--目录-->
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.7.2/jquery.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js" type="text/javascript" ></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.tocify/1.9.0/javascripts/jquery.tocify.min.js" type="text/javascript" ></script>
        
<script src="../../../../../js/toc.js"></script>

    

    
<script src="../../../../../js/randomHeaderContent.js"></script>

    <!--回到顶部按钮-->
    
        
<script src="../../../../../js/returnToTop.js"></script>

    

    
        
<script src="../../../../../js/returnToLastPage.js"></script>

    





<script src="../../../../../js/lightgallery/lightgallery.umd.min.js"></script>



<script src="../../../../../js/lightgallery/plugins/lg-thumbnail.umd.min.js"></script>



<script src="../../../../../js/lightgallery/plugins/lg-fullscreen.umd.min.js"></script>


<script src="../../../../../js/lightgallery/plugins/lg-autoplay.umd.min.js"></script>


<script src="../../../../../js/lightgallery/plugins/lg-zoom.umd.min.js"></script>


<script src="../../../../../js/lightgallery/plugins/lg-rotate.umd.min.js"></script>


<script src="../../../../../js/lightgallery/plugins/lg-paper.umd.min.js"></script>




<script type="text/javascript">
     
    if (typeof lightGallery !== "undefined") {
        var options1 = {
            selector: '.gallery-item',
            plugins: [lgThumbnail, lgFullscreen, lgAutoplay, lgZoom, lgRotate, lgPager], // 启用插件
            thumbnail: true,          // 显示缩略图
            zoom: true,               // 启用缩放功
            rotate: true,             // 启用旋转功能能
            autoplay: true,        // 启用自动播放功能
            fullScreen: true,      // 启用全屏功能
            pager: false, //页码,
            zoomFromOrigin: true,   // 从原始位置缩放
            actualSize: true,       // 启用查看实际大小的功能
            enableZoomAfter: 300,    // 延迟缩放，确保图片加载完成后可缩放
        };
        lightGallery(document.getElementsByClassName('.article-gallery')[0], options1); // 修复选择器
    }
    
</script>


    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script> 

                </div>
            
            
                <!-- 回到顶部的按钮-->  
                <div class="progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
            
                <!-- 返回的按钮-->  
                <div class="return-to-last-progress-wrap shadow-drop-2-bottom">
                    <svg class="progress-circle svg-content" width="100%" height="100%" viewBox="-1 -1 102 102">
                        <path d="M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98"/>
                    </svg>
                </div>
            
    </body>
</html>